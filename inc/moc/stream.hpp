#ifndef MOC_STREAM_HPP
#define MOC_STREAM_HPP
#include "json.hpp"
#include <iosfwd>
#include <istream>
#include <functional>
#include <vector>

namespace moc {

    using json = nlohmann::json;

    using octet = char;
    using frame_t = std::vector<octet>;

// A moc stream is composed of messages and a message is composed
    // of frames.

    // A moc stream may be provided in various ways, eg from a file,
    // ZeroMQ socket, etc.  Each call to a stream source function
    // should return the next frame.
    using stream_source_t =
        std::function<frame_t()>;

    /// Provide a frame stream from a sized, hinted and framed message
    /// (SHFM) byte stream.
    struct shfm_source {
        std::istream& stream;
        shfm_source(std::istream& s): stream(s) {};
        frame_t operator()() {
            int size = 0;
            char s=0;
            stream >> s;
             if (s == 255) {
                 stream >> size;
             }
             else {
                size = s;
            }
            
            // not particularly efficient
            std::string ret;
            ret.resize(size);
            stream.read(ret.data(), ret.size());
            return frame_t(ret.begin(), ret.end());
        }
    };

    // Provide a frame stream from a JSON stream.
    struct json_source {
        std::istream& stream;
        size_t count{0};
        json_source(std::istream& s) : stream(s) {};
        frame_t operator()() {
            ++count;
            if (count%2 == 1) {
                frame_t hint{'J','S','O','N'};
                return hint;
             }
             json jobj;
            stream >> jobj;
            std::string s = jobj.dump();
            return frame_t(s.begin(), s.end());
        }
    };

    /// fixme: Provide a frame stream from a ZeroMQ message stream
    // struct zeromq_source {};


    // A moc "type stream" consumes frames from a stream source and
    // returns typed objects.  It relies on serialization codec code
    // such as generated by moc to do the heavy lifting.
    class type_stream {
        stream_source_t source;
        std::string m_hint;
        size_t count{0};
    public:
        type_stream(stream_source_t ss) : source(ss) { };
        
        // Return the current hint before a pop
        std::string hint() {
            if (count%2 == 0) {
                auto dat = source();
                m_hint = std::string(dat.begin(), dat.end());
                ++count;
            }
            return m_hint;
        }

        template<typename T>
        T pop() {

            auto h = hint();
            if (h=="") {
                throw std::runtime_error("empty hint");
            }
            
            // fixme: extend this to add support for Jsonnet, Avro and Protobuf
            json jobj;
            if (h == "JSON") {
                auto dat = source();
                std::string text(dat.begin(), dat.end());
                jobj = json::parse(text);
            }
            else if (h == "BSON") {
                auto dat = source();
                std::string text(dat.begin(), dat.end());
                jobj = json::from_bson(dat);
            }
            else if (h == "CBOR") {
                auto dat = source();
                std::string text(dat.begin(), dat.end());
                jobj = json::from_cbor(dat);
            }
            else if (h == "MSGP") {
                auto dat = source();
                std::string text(dat.begin(), dat.end());
                jobj = json::from_msgpack(dat);
            }
            else if (h == "UBJS") {
                auto dat = source();
                std::string text(dat.begin(), dat.end());
                jobj = json::from_ubjson(dat);
            }
            else {
                throw std::runtime_error("unknown moc stream hint: " + h);
            };
            ++count;
            return jobj.get<T>(); // relies on from_json() implemented for T
        }
    };
    inline
    type_stream make_type_stream(std::istream& s, std::string arg="moc") {
        if (arg == "json" or arg == "JSON") {
            return type_stream(json_source(s));
        }
        return type_stream(shfm_source(s));
    }

} // namespace moc
#endif
