#ifndef MOC_STREAM_HPP
#define MOC_STREAM_HPP

#include <istream>
#include <functional>
#include "json.hpp"

namespace moc {

    using json = nlohmann::json;

    // A moc stream provides ordered configuration objects.  At lowest
    // level a moc stream is a sequence of bytes.  Next it is a
    // sequence of "frames" which are simply a sequence of N bytes,
    // prefixed N.  Where N is less than 255 it is held as a single
    // byte and otherwise as four bytes.  One or more frames may be
    // grouped in some way and the group is called a message.  moc
    // requires the initial frame of a message to be an array of ASCII
    // characters that provide a hint as how many subsequent frames
    // are considered as part of the message and how these frames are
    // to be interpeted.  For consider this stream which depicts a
    // frame as [size|content]:
    // 
    //     [4|JSON][8|{"a":42}]
    //
    // This is two frames, the first is 4 bytes holding ascii "JSON"
    // (no terminateing \0 character).  The next frame is 8 bytes and
    // as the hint indicates, is to be interpreted as JSON text.
    //
    // Currently moc supports any format supported by nlohmann::json
    // with the following 4 character hints: JSON, BSON, CBOR, MSGP
    // (MessagePack), UBJS (UBJSON).  After a hint frame is exactly
    // one body frame holding data in the hinted format.

    // A moc stream may be provided in various ways, eg from a file,
    // ZeroMQ socket, etc.  Each call to a stream source function
    // should return the next frame.
    using stream_source_t =
        std::function<std::vector<std::byte>()>;

    /// A stream source from any istream.
    struct istream_source {
        std::istream& stream;
        file_source(std::istream& s): stream(s) {};
        std::vector<std::byte> operator()() {
            int size = 0;
            char s=0;
            stream >> s;
            if (s == 255) {
                stream >> size;
            }
            else {
                size = s;
            }
            std::vector<std::byte> ret(size);
            stream.read(ret.data(), size);
            return ret;
        }
    };

    

    /// fixme: todo:
    // struct zeromq_source {};

    // A moc "type stream" takes a moc stream and performs
    // serialization to restore types.  It relies on serialization
    // code such as generated by moc to do the heavy lifting.

    class type_stream {
        stream_source_t source;
      public:
        type_stream(stream_source_t ss) : source(ss) { };
        
        template<typename T>
        T pop() {
            auto data = source();
            std::string hint(static_cast<const char*>(dat.data()), dat.size());
            json jobj;
            if (hint == "JSON") {
                dat = source();
                std::string text(static_cast<const char*>(dat.data()), dat.size());
                jobj.parse(text);
            }
            else if (hint == "BSON") {
                dat = source();
                std::string text(static_cast<const char*>(dat.data()), dat.size());
                jobj = json::from_bson(dat);
            }
            else if (hint == "CBOR") {
                dat = source();
                std::string text(static_cast<const char*>(dat.data()), dat.size());
                jobj = json::from_cbor(dat);
            }
            else if (hint == "MSGP") {
                dat = source();
                std::string text(static_cast<const char*>(dat.data()), dat.size());
                jobj = json::from_msgpack(dat);
            }
            else if (hint == "UBJS") {
                dat = source();
                std::string text(static_cast<const char*>(dat.data()), dat.size());
                jobj = json::from_ubjson(dat);
            }
            else {
                throw std::runtime_error("unkown moc stream hint");
            };
            return jobj.get<T>(); // relies on from_json() implemented
        }
    };
}
#endif
