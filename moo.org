#+title: moo ç„¡
#+subtitle: Model Oriented Objects
#+setupfile: setup.org
#+options: broken-links:mark


* Introduction
  :PROPERTIES:
  :CUSTOM_ID: intro
  :END:


Model-oriented objects (*moo*) generates code by applying a code
/template/ to a data structure (the model).  

#+begin_center
$moo(M, T) \to C$
#+end_center

This is an age old idea and *moo* is particularly influenced by the code
generator [[https://github.com/zeromq/gsl][gsl]] as it is applied to [[https://github.com/zeromq/zproto][zproto]]/[[https://github.com/zeromq/zproject][zproject]] templates by the
ZeroMQ community to generate client, servers, protocols and entire
software projects.  *moo*'s contributions to this idea include:

- support for defining models in essentially any data language that
  can produce valid data structure, specifically all supported by the
  [[https://github.com/ssato/python-anyconfig][anyconfig]] Python package (JSON, YAML, XML, INI, etc).

- special support for defining models in the [[https://jsonnet.org][Jsonnet]] data language.

- support for defining model schema in the vocabulary of [[http://json-schema.org/][JSON Schema]].
  Schema may be developed in all the same languages as models and *moo*
  provides special support for Jsonnet, including a Jsonnet interface
  to JSON Schema vocabulary.

- defining templates in the [[https://jinja.palletsprojects.com][Jinja2]] template markup used in many other
  projects.

- a command line, Python modules and example [[https://waf.io][Waf]] build system that
  shows how one may compile, , validation and render models into code
  and build and test that code.

The change in languages adopted by *moo* is expected to enable better
project factoring, model and template reuse and easier development.


** Quick start
   :PROPERTIES:
   :CUSTOM_ID: quickstart
   :END:

The ~moo~ command line and Python module is provided as a Python
package and is installed in the "usual way".  Here is one:

#+begin_example
  $ git clone https://github.com/brettviren/moo.git
  $ python3 -m venv venv
  $ source venv/bin/activate
  $ pip install -e .
  $ moo --help
  $ moo validate --help
  $ moo validate moo/moo.jsonnet
#+end_example

** Hello codegen
   :PROPERTIES:
   :CUSTOM_ID: hello-codgen
   :END:

In this example we develop a trivial schema, a model that adheres to
the schema and a template that accepts schema-valid models.  We defer
any explanation until later sections.

*** Hello model
    :PROPERTIES:
    :CUSTOM_ID: hello-model
    :END:


Our first "hello" model is very simple.  

#+include: hello/model_hp.jsonnet src jsonnet

This example is so simple that the use of Jsonnet rather than base
JSON seems like overkill.  However, for anyone that has ever had to
write raw JSON, simply being able to drop quotes around keys and leave
in a final comma makes Jsonnet so much more human friendly.  As our
models grown in complexity we will see how Jsonnet becomes even more
useful and how *moo* provides some additional help.

We can /compile/ the Jsonnet to JSON with the ~moo~ command line program:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "name": "moo home page",
    "url": "https://brettviren.github.io/moo"
}
#+end_src

That's it.  That's our boring object.  Next, let's put it to use.

*** Hello template

It is the template where the abstract model is made real.  We may
write many types of templates that all accept many models which adhere
to a particular schema.  Here we show two.

First is a simple web page which interprets the model as an HTML link.

#+include: hello/link.html.j2 src html

Note the model data structure is available as a Jinja2 parameter
~model~.  Other parameters may be included, for example, *moo* will pass
in a ~moo~ parameter holding a helpful data structure and we will see
this used in the codec example.

We may /render/ the template against the model with the ~moo~ command line
program:

#+begin_src shell :exports both :results output code :wrap "src html"
  moo render hello/model_hp.jsonnet hello/link.html.j2
#+end_src

#+RESULTS:
#+begin_src html
<html>
<a href=""></a>
</html>
#+end_src

A boring web page for a boring model.

The second "hello" example template is a simple command line tool that
bakes in specific targets for download.

#+include: hello/downloader.sh.j2 src shell

It is rendered with:

#+begin_src shell :exports both :results output code :wrap "src shell"
  moo render hello/model_hp.jsonnet hello/downloader.sh.j2
#+end_src

#+RESULTS:
#+begin_src shell
#!/bin/bash
echo "Downloading moo home page"
wget -O "moo home page" "https://brettviren.github.io/moo"
#+end_src


*** Hello schema
    :PROPERTIES:
    :CUSTOM_ID: hello-schema
    :END:

In *moo*, schema is used to specify how a valid model must be
structured in order to form a contract between model and template
developers.

Here is our "hello" schema which may validate our "hello" model:

#+include: hello/schema.jsonnet src jsonnet

We start to see some non-trivial Jsonnet.  A tutorial on Jsonnet won't
be included here instead we point the interested reader to the well
written [[https://jsonnet.org/learning/tutorial.html][Jsonnet]]
tutorial and [[https://jsonnet.org/ref/stdlib.html][standard]] library
reference.  

One thing to take note of is the first line:

#+begin_src jsonnet
local moo = import "moo.jsonnet";
#+end_src

This ~moo.jsonnet~ module provides all of *moo*'s extra support for
Jsonnet.  For most schema and models developed in Jsonnet it will be
helpful to use.  It is found in the ~moo~ Python package directory and
is located automatically by the ~moo~ command line program.  The user
may provide their own Jsonnet libraries.

Like with a model file we may compile a schema file to JSON with the ~moo~ command line program:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile hello/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "properties": {
        "name": {
            "type": "string"
        },
        "url": {
            "format": "uri",
            "type": "string"
        }
    },
    "required": [
        "name",
        "url"
    ],
    "type": "object"
}
#+end_src

This is example of a JSON document that follows the vocabulary of JSON
Schema.  We won't give a tutorial on JSON Schema either but is a simple vocabulary and the reader is suggested to read the document [[http://json-schema.org/understanding-json-schema/][Understanding JSON Schema]].

This "hello" schema will accept a model as valid if it has two
attributes: ~name~ which has a value of string and ~url~ which is also
a string following a particular format.

We may use the ~moo~ command line program to perform validation of the
"hello" model against this schema.  It relies on the Python package [[https://python-jsonschema.readthedocs.io][jsonschema]]
for the heavy lifting and its coverage of JSON Schema specification.

#+begin_src shell :exports both :results output code :wrap "src json"
  moo validate -s hello/schema.jsonnet hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
#+end_src

The lack of any error here indicates validity.  We can disturb the
model by removing a required attribute key or providing a value of the
wrong type.  For example, let us change the ~url~ attribute value to
hold the integer ~42~.

#+include: hello/model_hp_invalid.jsonnet src jsonnet

Note, this uses a Jsonnet language feature to reuse first model and
override just its ~url~ attribute with a new one.  If the first model
changes in orthogonal ways, this derived model need not.  In any case,
we can now determine that new model is no longer valid against the
schema:

#+begin_src shell :exports both :results output code :wrap "example"
  moo validate -s hello/schema.jsonnet hello/model_hp_invalid.jsonnet 2>&1 |tail -7
#+end_src

#+RESULTS:
#+begin_example
jsonschema.exceptions.ValidationError: 42 is not of type 'string'

Failed validating 'type' in schema['properties']['url']:
    {'format': 'uri', 'type': 'string'}

On instance['url']:
    42
#+end_example

*** Hello build
    :PROPERTIES:
    :CUSTOM_ID: hello-building
    :END:

This example is simple enough that command line invocations are
sufficient.  As our system of schema, models and templates grow, a
layer of automated task generation becomes rather welcome.  *moo*
provides a Waf-based example of that.  The main
[[file:wscript][~wscript~]] file may be used as a starting point and our
"hello" example provides a [[file:hello/wscript_build][~wscript_build~]]
file showing how one may extend the main wscript to handle
domain-specific codegen.

#+include: hello/wscript_build src python

And build:
#+begin_example
  $ waf configure
  $ waf
  $ ls build/hello_*
  build/hello_downloader.sh  build/hello_link.html
#+end_example

This build is fairly simple and so the ~wscript_build~ file is
hand-crafted.  Clearly the right thing to do is to "render" a *moo*
model into a set of Waf tasks.  In this case instead of using a Jinja2
template, Waf task generator would be developed that directly
interpreters *moo* models and spawns the tasks.


* A codec
   :PROPERTIES:
   :CUSTOM_ID: ex-codec
   :END:

This section uses *moo* to develop an extended (although for now
rather incomplete) example to show more of what may be accomplished
with *moo*.  We describe the project and then dive into its schema,
models and templates and end with some ideas for where to go next.

The goal of the project will be to generate code which implements a
/codec/.  Here, a codec means software that can serialize a data
structure represented as native language types (eg a C++ ~struct~)
into a series of bytes (encode) and from a properly encoded series of
bytes reproduce the structure (decode).  One way to illustrate a codec
is shown in the following diagram:

[[file:./codec.svg]]

The /recv/ represents a source of encoded data or /messages/ (eg a
socket) and likewise the /send/ is a sink.  The codec will define a
number of different /types/ of messages.  In the diagram, the data
structure held in the messages is represented by the /fields/ node.
The /id/ is a special field made explicit and is used to represent the
message type or the mapping between encoding and structure.  The
/setters/ and /getters/ represent field accessor methods such as may
be used by an application to modify or query the current value held in
the codec.

In general, a codec will have multiple, related message types.  It is
likely that they will share some fields which are identical in name,
type and semantic meaning.  There are two extremes in how one may
realize this

The first extreme presents the /fields/ as a flat set of attributes
where only those attributes which are mapped to the current /id/ are
considered valid for calling.  The codec API then provides one
/getter/ and one /setter/ method for the union of fields across all
supported messages.  This is the idiom adopted by ZeroMQ Zproto and
has a benefit in minimizing copies.  Assuring only accessors
associated with the current /id/ are accessed is troublesome for
hand-crafted code but as Zproto also generated most of the
application, this collusion is easy to assure in practice.

The other extreme is to maintain strict one-to-one mapping between
message type and a native language type (typically a ~struct~ or
~class~).  The codec API then provides one /getter/ and one /setter/
for each message type which allows atomic access to the corresponding
native language type.  This is the idiom of, for example, use of
Protobuf serialization.  The explicit retaining of an atomic object is
convenient for hand-crafted code.  It does require more copying and
tends to encourage the serialization objects to permeate through
application code.

The concerns in the development of our fledgling codec include:

- schema :: we will expect our models to describe messages types in
  terms of an /id/ of type string and a /body/ which is specified as a
  schema.

- model :: our model will describe various message types such as may
  be used to enact control, configuration and monitoring (CCM) of a
  distributed system

- templates :: we will make templates to define C++ types
  corresponding to each message, C++ functions to serialize them using
  at least two methods (JSON and MessagePack), test code,
  documentation, etc.  (But, really, for now we merely render message
  type models to their C++ ~struct~)

* Schema
  :PROPERTIES:
  :CUSTOM_ID: schema
  :END:

This section gives details on *moo* schema in the context of the codec
example

** Validation vs assertion
   :PROPERTIES:
   :CUSTOM_ID: valid-v-assert
   :END:


The primary purpose of a schema document in *moo* is to provide a
/contract/ between model and template developers.  We wish to write
$N_M$ models which may be applied to $N_T$ templates.  An implicit
contract must be validated by looking for errors in $N_M \times N_T$
renderings.  By insinuating an explicit contract, many errors can be
detected in $N_M$ validations against the schema.  For this use we
write data structures in the vocabulary of JSON Schema.

The second use of schema in *moo* is to assert structure for the
purpose of generating its implementation.  For example, we want to
render a model of a codec message type into a C++ ~struct~.  Unlike
validation which may need to be more accepting, schema to assert
structure must not have any ambiguity.  

A subset of JSON Schema vocabulary may be used to assert unambiguous
schema, however it has two practical problems.  First, it adds extra
layers of structure in order to support meta information (eg, the
~"requires"~ and ~"parameters"~ keywords of a JSON Schema ~object~).
Iterating models with this extra structure puts a fairly large burden
on template development.  The second problem is that JSON Schema
vocabulary only supports the data types found in JSON (array, object,
string, number, Boolean).  To generate code we need a more expressive
set of types (eg, "unsigned 64 bit integer").  JSON Schema ~object~
could be extended to include non-standard keywords to support these
extensions.  However, we may provide this extension more simply and
solve the first problem by developing our own assertion schema (which
we do below in [[Models]]).

** Jsonnet vs JSON Schema
   :PROPERTIES:
   :CUSTOM_ID: js-v-js
   :END:


With *moo* we may provide data structures represented in many languages.
Any language format supported by the ~anyconfig~ Python module or any
language that may produce such formats may be used.  In particular,
*moo* provides support for creating data structures for *moo* using
Jsonnet.  The reason why such variety can be supported by *moo* is that
schema validation, application of model to template and other
operations all occur on data structures in memory.  Populating those
structures from a particular persistent representation is factored out
and parameterized by the format.  This may be extended in the future
to support data structures loaded from SQL or noSQL type stores.

Thus, to develop your own schema data structures with *moo*'s Jsonnet,
first spend some quality time with
[[http://json-schema.org/understanding-json-schema/][Understanding
JSON Schema]].  This document provides a fast and excellent learning
resource to understand JSON Schema.  A large, if not complete,
fraction of JSON Schema is reflected into ~moo.schema~ functions so as
you learn JSON Schema focus on structure not on syntax and you may
then map JSON Schema keywords into *moo* Jsonnet functions.

As we will see used next, *moo* Jsonnet also provides additional schema
to more exactly specify types including attributes for numeric sizes,
formats, units.

** Codec schema
   :PROPERTIES:
   :CUSTOM_ID: codec-schema
   :END:

Here is an outline of a schema which broadly specifies a codec for the
purpose of this example:

- A codec has some number of message types and each type has an attribute:
- ~ident~ giving a unique message type identifier and
- ~body~ which holds schema describing the structure of the message payload.

Based on such a schema, a number of models are developed each of which
a number of message types and each of those which provides an ~ident~
value and a ~body~ schema.  And, with the schema in hand, a variety of
templates are developed which may generate code given any one of these
models.

In practice, a codec typically goes further to specify in detail how
every bit of schema maps to a byte stream.  We will leave this as an
implementation detail left to a /serialization/ method chosen by the
template.  This means that we do not expect to convert an data object
produced by code generated from one model/template pair to necessarily
be compatible with code generated from the same model but a different
template.  Instead, we will need to organize templates into compatible
categories.  For example, one template may produce C++ native types
structure which may be shared by a variety of templates producing
individual serialization methods.  An application must take care to
match both ends of a data stream with matching serialization but may
use the same model.  OTOH, we may also produce Python native types
which are compatible with C++ native types when joined by suitably
matching Python and C++ ends of serialization methods.

In any case, in a formal *moo* Jsonnet schema the codec schema can be
defined as:

#+include: codec/schema.jsonnet src jsonnet

We expose sub-schema (eg ~mtype~) so that this schema may be easily
reused in other, larger schema.  We take the convention that the
"final result" schema for this file is found as the keyword ~schema~.  

The ~body~ keyword is set to the output of ~moo.schema.jsonschema()~.
This says that any valid model may provide a value for a ~body~ keyword
which is itself some form of valid JSON Schema.  This is a rather
open-ended contract which still puts a burden on template developers
to implement any valid JSON Schema structure.  With that challenge
overcome, one may then have a fully generic (up to requiring the
~ident~) system.  We can lighten the burden by applying more
"opinionated" schema for ~body~.  For example, we may limit the ~body~ to
specify it as a "flat" object with its attributes only consisting of
scalar strings and numbers.  For this codec example, we will "cheat"
and say that the models and the templates will share an unspecified
sub-contract which keep structure simple in hopes that some future
development brings wealth of full generality.

Another detail to note is the use of ~std.prune()~ in defining the final
schema.  This reduction removes any ~null~ entries that may arise.  For
example, a ~string()~ takes an optional ~format~ argument which defaults
to ~null~.  We can bury this inside each Jsonnet schema function but its
repeated call tends to degrade performance compared to a one-time
traversal of the final data structure.

To drop down one level of meta, here is the codec schema compiled to
JSON Schema:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P schema codec/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "properties": {
        "mtypes": {
            "items": {
                "properties": {
                    "body": {
                        "$ref": "https://json-schema.org/draft-07/schema"
                    },
                    "ident": {
                        "type": "string"
                    }
                },
                "required": [
                    "ident"
                ],
                "type": "object"
            },
            "type": "array"
        },
        "namepath": {
            "items": {
                "type": "string"
            },
            "type": "array"
        }
    },
    "type": "object"
}
#+end_src


Note how JSON Schema '$ref' keyword is used to refer to schema held
externally to avoid having to copy its contents.  

We may also validate this schema with the ~moo validate~ command.  In
general this command takes a ~-s/--schema~ option to set the schema
against which we validate the argument (eg a file holding a model).
Here, our schema file is the argument and we rely on the default
validation schema to be JSON Schema itself, represented *as* JSON
Schema, no less and just as we see used in the ~body~ attribute.  We see
the convoluted recursion in full force here, but in the end it all
works:.

#+begin_src shell :exports both :results output code :wrap "example"
  moo validate codec/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_example
#+end_example

No news is good news.


* Models
  :PROPERTIES:
  :CUSTOM_ID: models
  :END:

In *moo*, a model is a data structure which describes some abstract
"thing" (object) with the goal that it may be applied to one or more
templates in order to generate code.  A model should adhere to (be
validated by) a schema.

** Modeling languages
   :PROPERTIES:
   :CUSTOM_ID: mod-lang
   :END:

Just as with a schema, a developer may define a model in many data
languages.  *moo* supports models written in JSON, XML, YAML, and
various others (anything supported by the ~anyconfig~ Python module).
And of course developers are free to develop models in any form that
may generate these formats.  What ultimately matters is the in-memory
model data structure.

That variety aside, *moo* provides special support for defining models
in Jsonnet.  In particular, it provides functions to help create a
model in ways that assure consistent forms across models and in ways
that tend to produce models which are, by construction, valid against
schema.

In a properly constructed *moo* ~schema.jsonnet~ file, these functions are
available under the ~.types~ attribute.  It should extend the ~.types~
structure from any inherited schema starting with what is provided by
~moo.jsonnet~.  Unlike the structure under ~.schema~, the structure
provided by ~.types~ functions is assertive and not used for validation.

** Codec models
   :PROPERTIES:
   :CUSTOM_ID: ccm-codec
   :END:

Here is a very simple codec for controlling, configuring and
monitoring a distributed system.

#+include: ccm/model.jsonnet src jsonnet

Consider the ~"config"~ message type for which we can individually show
as JSON Schema like:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P mtypes.0 ccm/model.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "body": {
        "cfgid": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        },
        "issued": {
            "def": 0,
            "dtype": "i8",
            "mootype": "num",
            "unit": "ms"
        },
        "role": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        }
    },
    "ident": "config"
}
#+end_src

** Roles and their implementation
   :PROPERTIES:
   :CUSTOM_ID: roles
   :END:

Real systems will have many entities to configure.  Considering the
system from a top-down view, we may define a number of abstract
"roles" that the entities enact and we will specify some portion of a
configuration object schema to be supported by a role.  With bottom-up
consideration we know that each implementation of any given entity
will need specific configuration parameters and thus also contribute
to the specification of configuration structure.

In this example we leave that "subclassing" to some external entity
which is resolved by the ~"cfgid"~.  Its value is perhaps used by the
entity as a key to look up a full configuration in some database.  

With more effort now, we may instead handle this complexity directly
in our model.  We could remove ~"cfgid"~ and instead model a ~"config"~
like message type for every implementation.  If the role-level
configuration is substantial, we'd like to factor it out or derive
from this base model to produce a per-implementation config.  

We show this latter technique with this contrived example:

#+include: ccm/server.jsonnet src jsonnet 
#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile ccm/server.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "body": {
        "cfgid": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        },
        "favorite_color": {
            "def": "purple",
            "dtype": "<U",
            "mootype": "str"
        },
        "issued": {
            "def": 0,
            "dtype": "i8",
            "mootype": "num",
            "unit": "ms"
        },
        "role": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        }
    },
    "ident": "config"
}
#+end_src

The same template that can consume each of the message type models in
~ccm/model.jsonnet~ will be able to consume this contrived specialized
implantation called "server".


* Templates
  :PROPERTIES:
  :CUSTOM_ID: templates
  :END:

In *moo*, templates are files written in some target language with
Jinja2 markup interspersed.  A template applied to a model to generate
code in that target language.  The template is developed with the
model's schema in mind.

** C++ class header template
   :PROPERTIES:
   :CUSTOM_ID: cpp-class-tmpl
   :END:

This section extends the CCM codec example but with a template that is
in principle generic to any codec model.  The first template to
illustrate is one that generates a native language C++ type for a
model of a message type.

#+include: codec/class_header.hpp.j2 src c++

And, when we apply the ccm model:

#+begin_src shell :exports both :results output code :wrap "src c++"
  moo render ccm/model.jsonnet codec/class_header.hpp.j2
#+end_src

#+RESULTS:
#+begin_src c++
#ifndef CCM_MESSAGES_HPP
#define CCM_MESSAGES_HPP

namespace ccm {
struct config {
    std::string ident = "config";
    std::string cfgid = "";
    int64_t issued = 0;
    std::string role = "";
};

struct start {
    std::string ident = "start";
    int64_t issued = 0;
};

struct stop {
    std::string ident = "stop";
    int64_t issued = 0;
};

struct log {
    std::string ident = "log";
    int64_t issued = 0;
    std::string level = "";
    std::string message = "";
};

}

#endif //  CCM_MESSAGES_HPP
#+end_src


* Forward

** Factoring
   :PROPERTIES:
   :CUSTOM_ID: factoring
   :END:


This codec example remained very simple and very incomplete.  Now,
that it is presented it should be clear more work is needed.  As the
scope of the development increases so will the complexity.  Some
factoring and reuse is needed.  For example:

- A class header file template should take a model which combines
  information about a the file, C++ namespace and finally the actual
  class.

- Such a model should be validated against a schema which is similarly
  factored into file, namespace and class declaration sub-schema.

- The template should be similarly factored using macros so these
  macros may be reused in different template contexts.

- The file model would be used in a ~wscript_build.j2~ macro to add
  Waf build tasks.

** Composition
   :PROPERTIES:
   :CUSTOM_ID: composition
   :END:

Both Jsonnet and JSON Schema have their own forms to /compose/ structure
through /references/.  This allows defining structure in one place and
using it in multiple places.  Jsonnet references are resolved during
compilation while JSON Schema references are purely logical and
resolved by some interpreter (in case of *moo*, that's the ~jsonschema~
Python module).  There are a number of trade-offs in selecting how to
employ references.

Jsonnet provides these idioms for composing structure with references:

- an object produced by one file may be referenced in another via
  ~import~.

- an object may be defined in a ~local~ variable and used multiple
  times within that file.

- structure produced by a file may be referenced within the structure
  with ~self~ or ~super~ keywords and ~$.~ paths.

The benefit of using Jsonnet references is that they are first class
elements of the Jsonnet language.  This means the Jsonnet compiler
will find mistakes.

A potential drawback is that the Jsonnet compiler resolves references
by replacing them in the output with a copy of what they reference.
When the same structure is referenced multiple times it leads to
duplication in the output.  Since no human need process the output
this (perfect) redundancy in the output typically does not lead to any
problems.  In some cases when the Jsonnet is very large and there are
costly Jsonnet function calls repeated in the structure, the
compilation time may be noticeably or even prohibitively slower.

There is one hard limitation in Jsonnet references and that is that
they must not be used to form a recursive data structure.  This will
lead to compilation errors (stack overflow).

With a much different syntax, JSON Schema references are provided
through a /special form/ in the JSON:

#+begin_src json
{ "$ref": "<path>" }
#+end_src

This entire special form, including the ~{}~'s, is replaced by the value
associated to the attribute found at ~"<path>"~ somewhere in the rest of
the JSON.  By convention, a ~"<path>"~ is expected to references an
attribute under a top level ~"definitions"~ attribute.  For example:

#+begin_src json
{ "$ref": "#/definitions/target" }
#+end_src

would be replaced by ~<content>~ as found at:

#+begin_src json
  {
      "definitions" : {
          "target" : <content>
      }
  }
#+end_src

JSON Schema also provides way to define a target with an ~$id~ attribute
but this feature is currently unsupported by the Python module
~jsonschema~ which *moo* relies on and we will discard it from
consideration.

In Jsonnet, the JSON Schema special form ~{ "$ref" : "<path>" }~ may be
created using a call to ~moo.schema.ref(<path>)~ and if the conventional
~"definitions"~ is used then a shorter ~moo.schema.ref("target")~ may be
used.

In either case, it is required for the Jsonnet developer to assure
that ~<path>~ is included in the output.  The conventional
~"definitions"~ may be provided to ~moo.schema.schema()~ as an
argument.

Unless a recursive data structure is required, or the Jsonnet
structure requires prohibitively long times to compile, it is
recommended to avoid JSON Schema referencing and rely on Jsonnet
referencing.

** Selection
   :PROPERTIES:
   :CUSTOM_ID: selection
   :END:

Schema is described in a nested way with schema being composed of more
schema (it's schemas all the way down).  It will often be the case
that a model or a template or both require a schema which is embedded
in a larger schema.  *moo* allows selecting sub-schema in two ways:
through Jsonnet and on the command line.

*** Jsonnet selection
    :PROPERTIES:
    :CUSTOM_ID: jsonnet-selection
    :END:

Jsonnet provides selection in the same way as composition, that is
through references.  One may construct a large schema in one Jsonnet
file and write a second Jsonnet file which imports the first and
exposes the desired subset.  The first may be written to assist in
this selection.  For example, if the main schema has:

#+begin_src jsonnet
  local defs = {
      broker: { ... },
  };
  {
      defs:: defs,
      schema : moo.schema.schema(...)
  }
#+end_src

Then this Jsonnet file can evaluate to just the broker:

#+include: pbc/broker-schema.jsonnet src jsonnet

*** Command line selection
    :PROPERTIES:
    :CUSTOM_ID: cli-selection
    :END:


The ~moo~ command line provides a way to reference into schema (and
model) structure.  For example, the schema that governs the ~url~
property of the top-level "hello" schema can be selected out during
compilation:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P properties.url hello/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "$id": null,
    "format": "uri",
    "type": "string"
}
#+end_src

The ~moo~ command also provides a way to simultaneously select a schema
path and a model path.

#+begin_src shell :exports both :results output code :wrap "src json"
  moo validate -D name -S properties.name -s hello/schema.jsonnet hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
selecting model substructure at name
selecting schema substructure at properties.name
#+end_src

Again, lack of any error shows a successful validation.





