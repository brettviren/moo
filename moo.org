#+title: moo 無 Model Oriented Objects
#+setupfile: other/setup-topic.org


* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

*moo* is a tool for schema driven code generation.

** Taxonomy

*moo* defines a conceptual taxonmy

- schema :: a data structure describing the structure of data (including schema).

- model :: a data structure which is valid against a schema

- template :: text in some target format which is marked up with directives that are parameterized in terms of a schema and provided by a valid model

- codegen :: an artifact generated by applying a model to a template each adhering to a schema.

** Operations

*moo* may operate on instances of the *moo* taxonomy in various ways

- compile :: transform a model or a schema from one representation to another
- imports :: calculate an implicit file dependencies in the file representation of a model, schema or template
- validate :: determine if a model adheres to a schema
- render :: generate code (or other forms) by applying a model to a template

** Uses

*moo* can be used for many things

- define a unified data model with generated types in multiple languages
- produce serialization methods for objects in a data model
- translate from *moo* schema to others such as Avro, Protobuf, JSON Schema
- generate "perfect" instances of complex code *patterns* such as finite state machines from simple models
- ...and more

* Version
  :PROPERTIES:
  :CUSTOM_ID: version
  :END:

The current *moo* version is...

#+begin_src shell :exports results :results output code :wrap "example"
  moo version
#+end_src

#+RESULTS[b57c6704ace54c0d65cec578308037290faa03d3]:
#+begin_example
0.6.1
#+end_example

...as of last time this file was updated.  See ~moo/version.py~ for the
definitive version.

* License

*moo* is free software and may be used under the terms described in file
[[file:COPYING][COPYING]].  These terms explicitly do NOT extend to any of your own
files which may be input to or output from *moo* software.

* Installation
  :PROPERTIES:
  :CUSTOM_ID: install
  :END:

*moo* requires Python 3.5 or newer.

*moo* installs in to your favorite Python environment in most of the
usual ways.  Some examples are given below.  Due to a name conflict
(this) *moo* is currently not distributed through PyPI.

** Python environment
   :PROPERTIES:
   :CUSTOM_ID: python-env
   :END:

Here, ~python~ is assumed to be Python 3.  Use whatever your favorite
Python environment is to assure that.  Some suggestions:

*** Python3 built in virtual environment

#+begin_example
  $ python3 -m venv venv
  $ source venv/bin/activiate
#+end_example

*** Direnv

Install ~direnv~ and activate it in your shell, then:

#+begin_example
  $ echo "layout python3" > .envrc
  $ direnv allow
#+end_example

See more at https://github.com/direnv/direnv

** Install a release
   :PROPERTIES:
   :CUSTOM_ID: install-rel
   :END:

Via a release tarball:

#+begin_example
  $ python -m pip install https://github.com/brettviren/moo/archive/0.4.1.tar.gz
#+end_example

Or, via git:

#+begin_example
  $ python -m pip install git+git://github.com/brettviren/moo.git@0.4.1#egg=moo
#+end_example


** Install development
   :PROPERTIES:
   :CUSTOM_ID: install-dev
   :END:

Just install:

#+begin_example
  $ python -m pip install git+git://github.com/brettviren/moo.git#egg=moo
#+end_example

Or, maybe you want to hack on the code:

#+begin_example
  $ git clone git@github.com:brettviren/moo.git
  $ cd moo
  $ pyton -m pip install -e .
#+end_example


** Testing

*moo* source provides many types of tests.  Below shows how to run the
different types of tests and their output from last time this document
was regenerated.  Besides these explicit examples, regenerating *moo*
documents runs various tests which are embedded as examples.

*** Shell level tests

The shell-level tests require BATS and [[https://github.com/bats-core/bats-core/][bats-core]] is the recommended
implementation.

#+begin_src shell :exports both :results output code :wrap "example"
  bats -j 8 test
#+end_src

#+RESULTS:
#+begin_example
1..55
ok 1 test any
ok 2 jsonnet returns high precision
ok 3 moo compile hides lost precision
ok 4 compile schema with enum
ok 5 render schema with enum
ok 6 check passing
ok 7 check failing
ok 8 template paths
ok 9 template paths user
ok 10 model paths
ok 11 model paths user
ok 12 resolve builtin template
ok 13 resolve builtin template with extra path
ok 14 imports find builtin template
ok 15 render template from user path
ok 16 render template from user path which imports builtin
ok 17 compile schema
ok 18 generate and compile codegen
ok 19 compile to non-existent
ok 20 imports to non-existent
ok 21 okay with existing
ok 22 okay with missing
ok 23 find jinja import via template path in moo imports
ok 24 find jinja import via template path in moo render
ok 25 compile with default TLA
ok 26 compile with TLA from CLI with int
ok 27 compile with TLA from CLI with float
ok 28 compile with TLA from CLI with bool
ok 29 compile with TLA from CLI with string
ok 30 compile with TLA from CLI with file
ok 31 trivial test
ok 32 compile oschema/sys example
ok 33 compile oschema/app example
ok 34 simple TLAs
ok 35 TLA as a file
ok 36 TLAs as in Jsonnet code
ok 37 moo dump
ok 38 moo simple render
ok 39 another TLA compile test
ok 40 moo transform feature
ok 41 moo graft feature with render
ok 42 multi element path and omodel
ok 43 moo validate anys
ok 44 compile t-s-t-p test input
ok 45 render ostructs on all-in-one model
ok 46 render ostructs on model1
ok 47 render ostructs on model2
ok 48 render onljs on all-in-one model
ok 49 render onljs on model1
ok 50 render onljs on model2
ok 51 render omsgp on all-in-one model
ok 52 render omsgp on model1
ok 53 render omsgp on model2
ok 54 test issue #2
ok 55 test issue #2 with MOO_LOAD_PATH
#+end_example


*** Python level tests

The Python-level tests require pytest.  Note, developers should not
disable warnings when running tests.  For the sake of brevity in this
document they are turned off as some 3rd party packages trigger noisy
but currently innocuous deprecation warnings.

#+begin_src shell :exports both :results output code :wrap "example"
  pytest --disable-warnings
#+end_src

#+RESULTS[544845d42c5c359a73f13fc6d310b9ef86567430]:
#+begin_example
============================= test session starts ==============================
platform linux -- Python 3.8.0, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /home/bv/dev/moo
collected 24 items

test/test_issue11.py .                                                   [  4%]
test/test_issue13.py ....                                                [ 20%]
test/test_issue16.py ..                                                  [ 29%]
test/test_issue27.py ...                                                 [ 41%]
test/test_moo_ogen.py .                                                  [ 45%]
test/test_moo_otypes.py .....                                            [ 66%]
test/test_moo_templates.py ..                                            [ 75%]
test/test_moo_util.py .....                                              [ 95%]
test/test_ogen_schema.py .                                               [100%]

======================== 24 passed, 2 warnings in 1.38s ========================
#+end_example



* Quick start
  :PROPERTIES:
  :CUSTOM_ID: punt
  :END:

The *moo* command line interface provides various commands and online
help:

#+begin_example
  $ moo --help
#+end_example

See links below for documentation which provides various examples.

* Documentation
  :PROPERTIES:
  :CUSTOM_ID: docs
  :END:

** Links
   :PROPERTIES:
   :CUSTOM_ID: links
   :END:

- home page :: https://brettviren.github.io/moo

- code repo :: https://github.com/brettviren/moo

- documentation :: 

  - [[file:moo.org][moo high level documentation]] (this file)

  - [[file:oschema.org][moo object schema paradigm]] how to define *schema* and use it to validate models, apply *models* to *templates* for example to implement *codegen* 

  - [[file:otypes.org][moo object types]] way to *create objects* with a valid-by-construction pattern in *Python*

  - [[file:ovalid.org][moo object validation]] to strongly check if existing objects are *valid against moo schema*.

  - [[file:buildsys.org][moo and build systems]] how to integrate *moo* codegen into various *build systems*

  - [[file:tla.org][moo and top-level arguments]] flexible way to *inject values* into a Jsonnet program

  - [[file:wcup.org][moo as Wire-Cell user package generator]] how *moo* can be used to generate a skeleton of an entire software project

  - [[file:reqs.org][moo for LaTeX and spreadsheet generator]] using *moo* in production of documentation

* Releases
  :PROPERTIES:
  :CUSTOM_ID: releases
  :END:

While ~moo~ has a ~0.y.z~ release, backward compatibility is not a strong
priority as all uses are also in flux.  ~y~ will increment with major
new features which may or may not be backward compatible.  ~z~ will
increment with minor bug fixes.

** Releasing
   :PROPERTIES:
   :CUSTOM_ID: releasing
   :END:

Notes to self on making a release: 

- edit [[file:moo/version.py]] to set release version
- reexport this and other documentation files, no cache and check for failures
  - bats/pytest runs as part of exporting this file
- ~git commit~ and ~git tag -am 'Pithy release message' X.Y.Z~ using matching string
- edit [[file:moo/version.py]] to go back to a dev version
- ~git commit~ and ~git push~ and ~git push --tags~
- visit github release page and add any useful details

* Etc
   :PROPERTIES:
   :CUSTOM_ID: etc
   :END:

The name *moo* is a play on the Japanese term 無 which may be
interpreted to English in a few ways.  Some are listed below along
with how the meaning reflects on aspects of *moo*.

- Untainted pure mind :: *moo* avoids being "opinionated", is centered
  on ideas expressed as abstract data structures and so can be used
  for a wide variety of things from generating code, documents or
  package skeletons.  *moo* forms its data structures by ingesting most
  of the popular file formats likely to be used.  And, *moo* can produce
  any file format for which a user may create a template.

- No strings attached :: *moo* is not intended to be an invasive tool.
  *moo* artifacts can be generated as desired and *moo* may be left
  behind.  *moo* does not lock-in particular formats.  *moo* extends this
  freedom to your own applications.  By adopting *moo* codegen
  philosophy an app need not lock-in itself to particular data
  formats, representations, or serializations technologies.

- Nothingness :: *moo* is not really anything itself but rather it is
  the bits that go between other real things which perform the "heavy
  lifting" (Jsonnet, anyconfig, Jinja, JSON Schema, user templates).
  *moo* lets apps embrace the power of this nothingness by switching
  developer effort away from repetitive programming tasks and toward
  data structure and template development and then through code
  generation that effort gains multiplicative power.

