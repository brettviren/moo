#+title: moo ç„¡
#+subtitle: Model Oriented Objects
#+setupfile: setup.org
#+options: broken-links:mark


* Introduction
  :PROPERTIES:
  :CUSTOM_ID: intro
  :END:


Model-oriented objects (moo) generates code by applying a code
/template/ to a data structure (the model).  

#+begin_center
$moo(M, T) \to C$
#+end_center

This is an age old idea and moo is particularly influenced by the code
generator [[https://github.com/zeromq/gsl][gsl]] as it is applied to [[https://github.com/zeromq/zproto][zproto]]/[[https://github.com/zeromq/zproject][zproject]] templates by the
ZeroMQ community.

moo provides a general basis for generation.  Some example of its
application include modeling and generating native language data
structures, their serialization methods, RPC or other protocol message
and endpoint behaviors (finite state machines), application and system
wide configuration methods and their configuration objects,
documentation, architectural and design diagrams and even artwork.

moo consists of these main aspects:

- A moo *model* is a data structure such as one might represent in JSON,
  YAML or in Python with ~dict~ and ~list~ objects and fundamental string
  and numeric types.  With moo you may define a model in many
  languages (JSON, XML, YAML and various others) and moo provides
  explicit support for using the [[https://jsonnet.org][Jsonnet]] data language.  See the
  section [[Models]] for details.

- A moo *template* is a file written primarily in whatever target code
  language (C++, Python, LaTeX, GraphViz dot, SQL, HTML, etc) which
  has [[https://jinja.palletsprojects.com][Jinja2]] template markup added.  Details are found in [[Templates]].

- Developers of models and templates should form a contract by
  producing a *schema*.  A model may then be validated against the
  schema to assure it provides a structure expected by the template.
  Some models themselves provide elements which are schema (eg,
  modeling a message type).  These models may include schema
  structure.  Schema data structures may be written in the same
  variety of languages as may models and moo provides support for
  Jsonnet.  In moo a schema data structure must be expressed as [[http://json-schema.org/][JSON
  Schema]] (regardless of the language).  moo includes a JSON Schema
  that validates JSON Schema and it may be used in user schema to
  validate models that include parts which are written as JSON Schema
  forms.  See the section [[Schema]] for more information.

- The ~moo~ Python module provides methods to handle all of the actions
  involved in the codegen including compiling of Jsonnet to JSON,
  reading Jsonnet, JSON, XML, YAML, etc into memory-resident data
  structures, validating those structures and finally applying them to
  a template to generate code.  See [[Python]].

- The ~moo~ program exposes the same functionality to the command line
  and is described more in [[Command]].

- A [[https://waf.io][Waf]] build system example is provided which demonstrates how to
  generate the tasks to generate code.  See [[Build]].

The remainder of this introduction provides a quick-start guide to
install the moo package and then walks through a simple "Hello
codegen!" example.  Remaining sections cover each main aspect listed above

** Quick start
   :PROPERTIES:
   :CUSTOM_ID: quickstart
   :END:

- install
- build
- ~moo --help~

** Hello codegen
   :PROPERTIES:
   :CUSTOM_ID: hello-codgen
   :END:

In this example we develop a trivial schema, a model that adheres to
the schema and a template that accepts schema-valid models.  We defer
any explanation until later sections.

*** Hello model
    :PROPERTIES:
    :CUSTOM_ID: hello-model
    :END:


Our first "hello" model is very simple.  

#+include: hello/model_hp.jsonnet src jsonnet

This example is simple that the use of Jsonnet rather than base JSON
hardly seems useful.  However, for anyone that has ever had to write
raw JSON, simply being able to drop quotes around keys and leave in a
final comma makes Jsonnet so much more human friendly.

As our models grown in complexity we will see how Jsonnet becomes even
more useful and how moo provides some additional help.

We can generate JSON:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "name": "moo home page",
    "url": "https://brettviren.github.io/moo"
}
#+end_src

That's it.  That's our boring object.  Next, let's put it to use.

*** Hello template

It is the template where all an abstract rubber model finally meets
the road.  We may write many types of templates that all accept many
models which adhere to a particular schema (see [[Hello schema]] next).
Here we show two.

First is a simple web page which interprets the model as an HTML link.

#+include: hello/link.html.j2 src html
#+begin_src shell :exports both :results output code :wrap "src html"
  moo generate hello/model_hp.jsonnet hello/link.html.j2
#+end_src

#+RESULTS:
#+begin_src html
<html>
<a href="https://brettviren.github.io/moo">moo home page</a>
</html>
#+end_src

The second is a simple command line tool that bakes in specific
targets for download.
#+include: hello/downloader.sh.j2 src shell
#+begin_src shell :exports both :results output code :wrap "src shell"
  moo generate hello/model_hp.jsonnet hello/downloader.sh.j2
#+end_src

#+RESULTS:
#+begin_src shell
#!/bin/bash
echo "Downloading moo home page"
wget -O "moo home page" "https://brettviren.github.io/moo"
#+end_src


*** Hello schema
    :PROPERTIES:
    :CUSTOM_ID: hello-schema
    :END:

In moo, schema is strictly optional but recommended.  It used to
specify how a compliant model may be structured in order to form a
contract between model and template developers.

Here is our "hello" schema which may validate our "hello" model:

#+include: hello/schema.jsonnet src jsonnet

We start to see some non-trivial Jsonnet and some support moo provides
for writing schema.  A tutorial on Jsonnet won't be included here
instead we point the interested reader to the well written [[https://jsonnet.org/learning/tutorial.html][Jsonnet
tutorial]] and [[https://jsonnet.org/ref/stdlib.html][standard library reference]].  But, one thing to take note
of is the first line:

#+begin_src jsonnet
local moo = import "moo.jsonnet";
#+end_src

This ~moo.jsonnet~ module provides all of moo's extra support for
Jsonnet.  For most schema and models developed in Jsonnet it will be
helpful to use.  It is found in the ~moo~ Python package directory and
is located automatically by the ~moo~ command line program.

We may compile this "hello" schema Jsonnet file using the C++ or Go
command line programs but the ~moo~ command is provided and brings some
additional convenience.

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile hello/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "properties": {
        "name": {
            "type": "string"
        },
        "url": {
            "format": "uri",
            "type": "string"
        }
    },
    "required": [
        "name",
        "url"
    ],
    "type": "object"
}
#+end_src

This "hello" schema will accept a model as valid if it has two
attributes: ~name~ which has a value of string and ~url~ which is also a
string following a particular format.  This is JSON Schema language
and to learn this simple language, see [[http://json-schema.org/understanding-json-schema/][Understanding JSON Schema]].

We may use the ~moo~ command line program to perform validation of the
model against the schema.  It relies on the Python package [[https://python-jsonschema.readthedocs.io][jsonschema]]
for the heavy lifting and its coverage of JSON Schema specification.

#+begin_src shell :exports both :results output code :wrap "src json"
  moo validate -s hello/schema.jsonnet hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
#+end_src

The lack of any error here indicates validity.  We can disturb the
model by removing a required attribute key or providing a value of the
wrong type.  For example, let us change the ~url~ attribute value to
hold the integer ~42~.

#+include: hello/model_hp_invalid.jsonnet src jsonnet

Note, this uses a Jsonnet language feature to reuse first model and
override just its ~url~ attribute with a new one.  If the first model
changes in orthogonal ways, this derived model need not.  In any case,
we can now determine that new model is no longer valid against the
schema:

#+begin_src shell :exports both :results output code :wrap "example"
  moo validate -s hello/schema.jsonnet hello/model_hp_invalid.jsonnet 2>&1 |tail -7
#+end_src

#+RESULTS:
#+begin_example
jsonschema.exceptions.ValidationError: 42 is not of type 'string'

Failed validating 'type' in schema['properties']['url']:
    {'format': 'uri', 'type': 'string'}

On instance['url']:
    42
#+end_example

*** Hello build
    :PROPERTIES:
    :CUSTOM_ID: hello-building
    :END:

This example is simple enough that command line invocations are
sufficient.  As our system of schema, models and templates grow, a
layer of automated task generation becomes rather welcome.  moo
provides a Waf-based example of that.  The main [[file:wscript][wscript]] file may be
used as a starting point and our "hello" example provides a
[[file:hello/wscript_build][wscript_build]] file showing how one may extend the main wscript to
handle domain-specific codegen.

#+include: hello/wscript_build src python

And build:
#+begin_example
  $ waf configure
  $ waf
  $ ls build/hello_*
#+end_example

This build is fairly simple and so each target is exhaustively listed.
As the number of targets grow we may exploit symmetries to codify the
Waf task generation.


* A codec
   :PROPERTIES:
   :CUSTOM_ID: going-forward
   :END:

This section uses moo to develop an extended example to show more of
what may be accomplished with moo.  The goal will be to generate code
which implements a /codec/.  Here, a codec means software that can
serialize a data structure that is represented by native language
types into a series of bytes (encode) and from a properly encoded
series of bytes reproduce the structure (decode).  One way to
illustrate a codec is shown in the following diagram:

[[file:./codec.svg]]

The /recv/ represents a source of encoded data or /messages/ and likewise
the /send/ is a sink.  We will allow different /types/ of encoded messages
to map differently to the data structure of the codec. In the diagram
the data structure is represented by the /fields/ node.  The /id/ is a
special field made explicit and is used to represent the message type
or the mapping from encoding to structure.  The /setters/ and /getters/
represent field accessor methods such as may be used by an application
to modify or query the current value held in the codec.

Given multiple message types, possibly sharing semantically identical
fields, there are two extremes how to represent the data structure
managed by the codec.

The first one is to present the /fields/ as a flat set of attributes
where only those attributes which are mapped to the current /id/ are
considered valid for calling.  The codec API then provides one /getter/
and one /setter/ method for the union of fields across all supported
messages.

The other extreme is to maintain strict one-to-one mapping between
message type and a native language type (typically a ~struct~ or ~class~).
The codec API then provides one /getter/ and one /setter/ for each message
type which allows atomic access to the corresponding native language
type.

The general development parts include: 

- schema :: we will expect our models to describe messages types in terms of an /id/ of type string and a /body/ which is specified as a schema.

- model :: our model describe message types such as may be used in a simple control, configure and monitor (CCM) system

- templates :: we will make templates to define C++ types corresponding to each message, C++ functions to serialize them using at least two methods (JSON and MessagePack), test code, documentation, etc.

** Schema
  :PROPERTIES:
  :CUSTOM_ID: schema
  :END:

In moo, schema plays a central role and we need to describe a bit
before diving in.  

The primary purpose of a schema document in moo is to provide a
/contract/ between model and template developers.  We wish to write
$N_M$ models which may be applied to $N_T$ templates.  Without such a
contract, we must validate by applying each template to each model and
look for failures.  This is a $N_M \times N_T$ process.  By
insinuating a contract in the form of a schema it becomes a $N_M +
N_T$ process.

The second use of schema is that sometimes our models need to describe
"types of things" and that is precisely what a schema does.  An
immediate example will include the codec message types.  Instead of
inventing a new way for models to express schema separate from the
schema used to validate models, moo uses the same schema language for
both purposes, JSON Schema.

This may sound convoluted and recursive, and it is.  However, there is
a schema written in JSON Schema which validates any schema written in
JSON Schema (including itself).  Thus we can include JSON Schema in
our schema and in our models.  

With moo we may provide data structures represented in many languages.
Any language format supported by the ~anyconfig~ Python module or any
language that may produce such formats may be used.  In particular,
moo provides support for creating data structures for moo using
Jsonnet.  The reason why such variety can be supported by moo is that
schema validation, application of model to template and other
operations all occur on data structures in memory.  Populating those
structures from a particular persistent representation is factored out
and parameterized by the format.  This may be extended in the future
to support data structures loaded from SQL or noSQL type stores.

Thus, to develop your own schema data structures with moo's Jsonnet,
first spend some quality time with [[http://json-schema.org/understanding-json-schema/][Understanding JSON Schema]].  This
document provides a fast and excellent learning resource to understand
JSON Schema.  A large, if not complete, fraction of JSON Schema is
reflected into ~moo.schema~ functions so as you learn JSON Schema focus
on structure not on syntax and you may then map JSON Schema keywords
into moo Jsonnet functions.  

As we will see used next, moo Jsonnet also provides additional schema
to more exactly specify types including attributes for numeric sizes,
formats, units.

*** Codec schema
   :PROPERTIES:
   :CUSTOM_ID: codec-schema
   :END:

Here is an outline of a schema which broadly specifies a codec for the
purpose of this example:

- A codec has some number of message types and each type has an attribute:
- ~ident~ giving a unique message type identifier and
- ~body~ which holds schema describing the structure of the message payload.

Based on such a schema, a number of models are developed each of which
a number of message types and each of those which provides an ~ident~
value and a ~body~ schema.  And, with the schema in hand, a variety of
templates are developed which may generate code given any one of these
models.

In practice, a codec typically goes further to specify in detail how
every bit of schema maps to a byte stream.  We will leave this as an
implementation detail left to a /serialization/ method chosen by the
template.  This means that we do not expect to convert an data object
produced by code generated from one model/template pair to necessarily
be compatible with code generated from the same model but a different
template.  Instead, we will need to organize templates into compatible
categories.  For example, one template may produce C++ native types
structure which may be shared by a variety of templates producing
individual serialization methods.  An application must take care to
match both ends of a data stream with matching serialization but may
use the same model.  OTOH, we may also produce Python native types
which are compatible with C++ native types when joined by suitably
matching Python and C++ ends of serialization methods.

In any case, in a formal moo Jsonnet schema the codec schema can be
defined as:

#+include: codec/schema.jsonnet src jsonnet

We expose sub-schema (eg ~mtype~) so that this schema may be easily
reused in other, larger schema.  We take the convention that the
"final result" schema for this file is found as the keyword ~schema~.  

The ~body~ keyword is set to the output of ~moo.schema.jsonschema()~.
This says that any valid model may provide a value for a ~body~ keyword
which is itself some form of valid JSON Schema.  This is a rather
open-ended contract which still puts a burden on template developers
to implement any valid JSON Schema structure.  With that challenge
overcome, one may then have a fully generic (up to requiring the
~ident~) system.  We can lighten the burden by applying more
"opinionated" schema for ~body~.  For example, we may limit the ~body~ to
specify it as a "flat" object with its attributes only consisting of
scalar strings and numbers.  For this codec example, we will "cheat"
and say that the models and the templates will share an unspecified
sub-contract which keep structure simple in hopes that some future
development brings wealth of full generality.

Another detail to note is the use of ~std.prune()~ in defining the final
schema.  This reduction removes any ~null~ entries that may arise.  For
example, a ~string()~ takes an optional ~format~ argument which defaults
to ~null~.  We can bury this inside each Jsonnet schema function but its
repeated call tends to degrade performance compared to a one-time
traversal of the final data structure.

To drop down one level of meta, here is the codec schema compiled to
JSON Schema:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P schema codec/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_example
{
    "items": {
        "properties": {
            "body": {
                "$ref": "https://json-schema.org/draft-07/schema"
            },
            "ident": {
                "type": "string"
            }
        },
        "required": [
            "ident"
        ],
        "type": "object"
    },
    "type": "array"
}
#+end_example


Note how JSON Schema '$ref' keyword is used to refer to schema held
externally to avoid having to copy its contents.  

We may also validate this schema with the ~moo validate~ command.  In
general this command takes a ~-s/--schema~ option to set the schema
against which we validate the argument (eg a file holding a model).
Here, our schema file is the argument and we rely on the default
validation schema to be JSON Schema itself, represented *as* JSON
Schema, no less and just as we see used in the ~body~ attribute.  We see
the convoluted recursion in full force here, but in the end it all
works:.

#+begin_src shell :exports both :results output code :wrap "example"
  moo validate codec/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_example
#+end_example

No news is good news.


** Models
  :PROPERTIES:
  :CUSTOM_ID: models
  :END:

In moo, a model is a data structure which describes some abstract
"thing" (object) with the goal that it may be applied to one or more
templates in order to generate code.  A model should adhere to (be
validated by) a schema as just discussed.

Just as with a schema, a developer may define a model in many data
languages.  moo supports models written in JSON, XML, YAML, and
various others (anything supported by the ~anyconfig~ Python module).
And of course developers are free to develop models in any form that
may generate these formats.  What ultimately matters is the in-memory
model data structure.

That variety aside, moo provides special support for defining models
in Jsonnet.  In particular, it provides functions to help create a
model in ways that assure consistent forms across models and in ways
that tend to produce models which are, by construction, valid against
schema.

In a properly constructed moo ~schema.jsonnet~ file, these functions are
available under the ~.types~ attribute.  It should extend the ~.types~
structure from any inherited schema starting with what is provided by
~moo.jsonnet~.  Unlike the structure under ~.schema~, the structure
provided by ~.types~ functions is assertive and not used for validation.

In this section will develop a model for the CCM codec example
described above.

#+include: ccm/model.jsonnet src jsonnet

Consider the ~"config"~ message type which we can show as JSON Schema
like:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P 0 ccm/model.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "body": {
        "cfgid": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        },
        "issued": {
            "dtype": "i8",
            "mootype": "num",
            "unit": "ms"
        },
        "role": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        }
    },
    "ident": "config"
}
#+end_src

Real systems will have many entities to configure.  Considering the
system from a top-down view, we may define a number of abstract
"roles" that the entities enact and we will specify some portion of a
configuration object schema to be supported by a role.  With bottom-up
consideration we know that each implementation of any given entity
will need specific configuration parameters and thus also contribute
to the specification of configuration structure.

In this example we leave that "subclassing" to some external entity
which is resolved by the ~"cfgid"~.  Its value is perhaps used by the
entity as a key to look up a full configuration in some database.  

With more effort now, we may instead handle this complexity directly
in our model.  We could remove ~"cfgid"~ and instead model a ~"config"~
like message type for every implementation.  If the role-level
configuration is substantial, we'd like to factor it out or derive
from this base model to produce a per-implementation config.  

We show this latter technique with this contrived example:

#+include: ccm/server.jsonnet src jsonnet 
#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile ccm/server.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "body": {
        "cfgid": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        },
        "favorite_color": {
            "def": "purple",
            "dtype": "<U",
            "mootype": "str"
        },
        "issued": {
            "dtype": "i8",
            "mootype": "num",
            "unit": "ms"
        },
        "role": {
            "def": "",
            "dtype": "<U",
            "mootype": "str"
        }
    },
    "ident": "config"
}
#+end_src

The same template that can consume each of the message type models in
~ccm/model.jsonnet~ will be able to consume this contrived specialized
implantation called "server".


** Templates
  :PROPERTIES:
  :CUSTOM_ID: templates
  :END:

In moo, templates are files written in some target language with
Jinja2 markup interspersed.  A template applied to a model to generate
code in that target language.  The template is developed with the
model's schema in mind.

This section extends the CCM codec example.  The first template to
illustrate is one that generates a native language C++ type for a
model of a message type.

#+include: codec/mtype-first-try.hpp.j2 src c++


And, when we apply the first ~"config"~ message type model by selecting
the zeroth element of the full model:

#+begin_src shell :exports both :results output code :wrap "src c++"
  moo generate -P 0 ccm/model.jsonnet codec/mtype-first-try.hpp.j2
#+end_src

#+RESULTS:
#+begin_src c++
// The message type 
#ifndef CONFIG
#define CONFIG

struct config {
    std::string ident = "config";
    std::string cfgid = "";
    int64_t issued = 0;
    std::string role = "";
};
#endif // 
#+end_src

Now, as the template file name indicates, this represents a first try
and there are many things that make it clearly inadequate.  In
particular, we would like a way to give a C++ namespace and maybe some
hint at what C++ header file this might live in so that we may include
that in the header guards.

* Command
  :PROPERTIES:
  :CUSTOM_ID: command
  :END:


* Python
  :PROPERTIES:
  :CUSTOM_ID: python
  :END:


* Build
  :PROPERTIES:
  :CUSTOM_ID: build
  :END:

* Other

** Composition
   :PROPERTIES:
   :CUSTOM_ID: composition
   :END:

Both Jsonnet and JSON Schema have their own forms to /compose/ structure
through /references/.  This allows defining structure in one place and
using it in multiple places.  Jsonnet references are resolved during
compilation while JSON Schema references are purely logical and
resolved by some interpreter (in case of moo, that's the ~jsonschema~
Python module).  There are a number of trade-offs in selecting how to
employ references.

Jsonnet provides these idioms for composing structure with references:

- an object produced by one file may be referenced in another via ~import~.
- an object may be defined in a ~local~ variable and used multiple times within that file. 
- structure produced by a file may be referenced within the structure with ~self~ or ~super~ keywords and ~$.~ paths.

The benefit of using Jsonnet references is that they are first class
elements of the Jsonnet language.  This means the Jsonnet compiler
will find mistakes.

A potential drawback is that the Jsonnet compiler resolves references
by replacing them in the output with a copy of what they reference.
When the same structure is referenced multiple times it leads to
duplication in the output.  Since no human need process the output
this (perfect) redundancy in the output typically does not lead to any
problems.  In some cases when the Jsonnet is very large and there are
costly Jsonnet function calls repeated in the structure, the
compilation time may be noticeably or even prohibitively slower.

There is one hard limitation in Jsonnet references and that is that
they must not be used to form a recursive data structure.  This will
lead to compilation errors (stack overflow).

With a much different syntax, JSON Schema references are provided
through a /special form/ in the JSON:

#+begin_src json
{ "$ref": "<path>" }
#+end_src

This entire special form, including the ~{}~'s, is replaced by the value
associated to the attribute found at ~"<path>"~ somewhere in the rest of
the JSON.  By convention, a ~"<path>"~ is expected to references an
attribute under a top level ~"definitions"~ attribute.  For example:

#+begin_src json
{ "$ref": "#/definitions/target" }
#+end_src

would be replaced by ~<content>~ as found at:

#+begin_src json
  {
      "definitions" : {
          "target" : <content>
      }
  }
#+end_src

JSON Schema also provides way to define a target with an ~$id~ attribute
but this feature is currently unsupported by the Python module
~jsonschema~ which moo relies on and we will discard it from
consideration.

In Jsonnet, the JSON Schema special form ~{ "$ref" : "<path>" }~ may be
created using a call to ~moo.schema.ref(<path>)~ and if the conventional
~"definitions"~ is used then a shorter ~moo.schema.ref("target")~ may be
used.

In either case, it is required for the Jsonnet developer to assure that
~<path>~ is included in the output.  The conventional ~"definitions"~ may be provided to ~moo.schema.schema()~ as an argument.

Unless a recursive data structure is required, or the Jsonnet
structure requires prohibitively long times to compile, it is
recommended to avoid JSON Schema referencing and rely on Jsonnet
referencing.

** Selection
   :PROPERTIES:
   :CUSTOM_ID: selection
   :END:

Schema is described in a nested way with schema being composed of more
schema (it's schemas all the way down).  It will often be the case
that a model or a template or both require a schema which is embedded
in a larger schema.  moo allows selecting sub-schema in two ways:
through Jsonnet and on the command line.

*** Jsonnet selection
    :PROPERTIES:
    :CUSTOM_ID: jsonnet-selection
    :END:

Jsonnet provides selection in the same way as composition, that is
through references.  One may construct a large schema in one Jsonnet
file and write a second Jsonnet file which imports the first and
exposes the desired subset.  The first may be written to assist in
this selection.  For example, if the main schema has:

#+begin_src jsonnet
  local defs = {
      broker: { ... },
  };
  {
      defs:: defs,
      schema : moo.schema.schema(...)
  }
#+end_src

Then this Jsonnet file can evaluate to just the broker:

#+include: pbc/broker-schema.jsonnet src jsonnet

*** Command line selection
    :PROPERTIES:
    :CUSTOM_ID: cli-selection
    :END:


The ~moo~ command line provides a way to reference into schema (and
model) structure.  For example, the schema that governs the ~url~
property of the top-level "hello" schema can be selected out during
compilation:

#+begin_src shell :exports both :results output code :wrap "src json"
  moo compile -P properties.url hello/schema.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
{
    "$id": null,
    "format": "uri",
    "type": "string"
}
#+end_src

The ~moo~ command also provides a way to simultaneously select a schema
path and a model path.

#+begin_src shell :exports both :results output code :wrap "src json"
  moo validate -D name -S properties.name -s hello/schema.jsonnet hello/model_hp.jsonnet
#+end_src

#+RESULTS:
#+begin_src json
selecting model substructure at name
selecting schema substructure at properties.name
#+end_src

Again, lack of any error shows a successful validation.





