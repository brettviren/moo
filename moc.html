<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-12 Fri 16:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>moc</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Brett Viren" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/darksun.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/hideshow.css"/>
<script type="text/javascript" src="export/styles/darksun/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/darksun.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/hideshow.js"></script>
<script type="text/javascript" src="export/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">moc
<br />
<span class="subtitle">Model Oriented Configuration</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#dive-in">Dive in</a></li>
<li><a href="#technical-design">Technical design</a>
<ul>
<li><a href="#stream-frame-message">Streams, frames and messages</a></li>
<li><a href="#message-types">Reserved message types</a></li>
<li><a href="#byte-stream-formats">Byte stream formats</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#example-schema">Example schema</a></li>
<li><a href="#payload-schema">Payload schema</a></li>
<li><a href="#intra-message">Intra-message Schema</a></li>
<li><a href="#inter-message">Inter-message schema</a></li>
</ul>
</li>
<li><a href="#org9728039">Demos</a>
<ul>
<li><a href="#org1837da8">Install prerequisites</a></li>
<li><a href="#run-the-demo">Run the demo</a></li>
<li><a href="#demo-framework">Demo framework</a></li>
<li><a href="#orgb0fc9bc">Demo details</a>
<ul>
<li><a href="#orgf228afe">Makefile driver</a></li>
<li><a href="#org9b6a5af">Mock application</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-overview" class="outline-2">
<h2 id="overview">Overview</h2>
<div class="outline-text-2" id="text-overview">
<p>
moc is a moo for a <i>configuration</i> system.  It provides::
</p>

<ul class="org-ul">
<li>a vocabulary for defining the <i>schema</i> that configuration information should follow.</li>

<li>tooling to validate configuration objects against their schema.</li>

<li>code generators creating native language (C++/Python) types and serialization methods between those types and configuration objects.</li>

<li>native language libraries and shell programs for producing and consuming configuration in a variety of <i>formats</i> and media including files and <i>streams</i>.</li>

<li>a demo application and configuration.</li>
</ul>
</div>
</div>

<div id="outline-container-dive-in" class="outline-2">
<h2 id="dive-in">Dive in</h2>
<div class="outline-text-2" id="text-dive-in">
<p>
moc is currently not production but rather provides a mock up demo.
To use it, first install the <code>moo</code> Python package eg like:
</p>

<pre class="example">
$ echo layout python3 &gt; .envrc
$ direnv allow
</pre>

<p>
Or, if you don't have <code>direnv</code>
</p>

<pre class="example">
$ python3 -m venv venv
$ source venv/bin/activiate
</pre>

<p>
Then install <code>moo</code>
</p>

<pre class="example">
$ pip install -e .
$ moo --help
</pre>

<p>
The moc demo is in <a href="moc/">moc/</a>:
</p>

<pre class="example">
$ cd moc
$ make
</pre>
</div>
</div>


<div id="outline-container-technical-design" class="outline-2">
<h2 id="technical-design">Technical design</h2>
<div class="outline-text-2" id="text-technical-design">
<p>
moc is a <b>moo</b> focused on generating configuration objects and various means to deliver them into an application.  This section describes aspects of the technical design.
</p>
</div>

<div id="outline-container-stream-frame-message" class="outline-3">
<h3 id="stream-frame-message">Streams, frames and messages</h3>
<div class="outline-text-3" id="text-stream-frame-message">
<p>
moc configuration data follows an abstract low level format which may be realized in a few ways and independently from the concrete high level schema of the delivered content.  This provides flexibility to an application to select how configuration information is delivered  
</p>

<p>
The abstract low level format is defined in terms of <b>streams</b> of <b>bytes</b>, <b>frames</b> and <b>messages</b> as described:
</p>

<dl class="org-dl">
<dt>bytes</dt><dd>A <b>moc byte stream</b> consists of a sequence of 8 bit bytes.  Several types of byte streams are supported by moc including commonly known ones (eg, a JSON object or a <a href="https://en.wikipedia.org/wiki/JSON_streaming">JSON stream</a> and ones suitable for message passing systems like ZeroMQ).  Some byte streams may place limits the format of information they carry (eg, a JSON Stream may be used only for JSON text).</dd>

<dt>frames</dt><dd>A <b>moc frame stream</b> consists of a logical sequence of frames derived from a bytes stream.  A frame is a contiguous and finite sequence of bytes which may be read into memory in an atomic manner.  If two byte streams support the format of a frame then they both shall decode an identical frame identically.</dd>

<dt>messages</dt><dd>A <b>moc message stream</b> consists of a logical sequence of messages derived from a frame stream.  The application may determine the extent and interpretation of the message by progressively examining the frames.  moc messages must have an initial frame, called the message type <b>hint</b> which must consist of only printable ASCII characters suitable for use in forming a C symbol.  moc reserves a number of hint values, listed in the table below which are to be used to identify the low-level format of the next and last frame in the message called the <b>payload</b>.  The application is free to extend the list of message type hints it supports.</dd>

<dt>types</dt><dd>A <b>moc type stream</b> produces a stream of objects in native language type.  It serializes messages from a moc message stream.  When used, the application must know the type expected.</dd>
</dl>
</div>
</div>

<div id="outline-container-message-types" class="outline-3">
<h3 id="message-types">Reserved message types</h3>
<div class="outline-text-3" id="text-message-types">
<p>
The set of reserved moc message type hints are:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">hint</th>
<th scope="col" class="org-left">payload encoding</th>
<th scope="col" class="org-left">C++</th>
<th scope="col" class="org-left">Python</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">JSON</td>
<td class="org-left">JSON string</td>
<td class="org-left">yes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">BSON</td>
<td class="org-left">Binary JSON</td>
<td class="org-left">yes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">CBOR</td>
<td class="org-left">Binary JSON</td>
<td class="org-left">yes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">UBJS</td>
<td class="org-left">Binary JSON</td>
<td class="org-left">yes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">MSGP</td>
<td class="org-left">Message Pack</td>
<td class="org-left">yes</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">JSNT</td>
<td class="org-left">Jsonnet string</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">AVRJ</td>
<td class="org-left">Avro JSON</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">AVRB</td>
<td class="org-left">Avro binary</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">PBUF</td>
<td class="org-left">Protobuf</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-byte-stream-formats" class="outline-3">
<h3 id="byte-stream-formats">Byte stream formats</h3>
<div class="outline-text-3" id="text-byte-stream-formats">
<p>
moc provides byte stream decoding for a few common types:
</p>

<dl class="org-dl">
<dt>JSON</dt><dd>the bytes stream is assumed to be a <a href="https://en.wikipedia.org/wiki/JSON_streaming">JSON stream</a>.  As it may only hold JSON format data the moc message type hint is implicitly and always <code>JSON</code>.  The stream may consist of an admixed concatenation of JSON types.  The first frame from a JSON byte stream is the string <code>JSON</code> which is implicitly generated.  The second frame will contain the JSON text of the first JSON type in the stream.  This then repeats until the stream is exhausted.  An trivial example of a JSON stream with a sequence of JSON objects:</dd>
</dl>

<div class="org-src-container">
<pre class="src src-json">{<span style="color: #b4fa70;">"greeting"</span>:<span style="color: #e9b96e;">"hi"</span>}{<span style="color: #b4fa70;">"greeting"</span>:<span style="color: #e9b96e;">"bye"</span>}
</pre>
</div>

<dl class="org-dl">
<dt>SHFM</dt><dd>a "size-hinted framed message" may hold arbitrary data (binary and text, including JSON) and is well suited for use with ZeroMQ or other message passing systems.  In the byte stream, a frame is prefixed with a binary value holding the size of the frame data measured in bytes.  If less than 255 the size value is stored in a single byte.  If the size is 255 or greater but less than 2<sup>32</sup>-1 the first byte is 255 (<code>0xff</code>) and the next four bytes hold the size as a 32 bit integer.  The first frame in a message shall provide the message type hint and for hints reserved by moc, the subsequent and only other frame in the message holds the payload frame of that type.  An example SHFM message is shown next with a frame depicted as <code>[ size | body ]</code> where the <code>size</code> in a binary value and the <code>body</code> is expressed in ASCII:</dd>
</dl>

<pre class="example">
[ 4 | JSON ][ 8 | {"a":42} ]
</pre>
</div>
</div>

<div id="outline-container-schema" class="outline-3">
<h3 id="schema">Schema</h3>
<div class="outline-text-3" id="text-schema">
<p>
When using reserved message types, the moc library can transparently handle a choice of both the byte stream (among the supported formats) and of low-level frame data format (ie, JSON vs Avro, etc).   The producer and consumer of a moc <b>message stream</b> must honor a shared <b>contract</b> which governs the structure of the data at three semantic layers:
</p>

<dl class="org-dl">
<dt>payload</dt><dd>the structure of information in given payload frame (format is handled by moc)</dd>
<dt>intra message</dt><dd>the structure of payload frames in a message (if using custom message types, moc reserved types only have one frame).</dd>
<dt>inter message</dt><dd>the number, structure, order and interpretation of messages in a stream.</dd>
</dl>

<p>
moc provides some means to rigorously define the contract, particularly as it pertains to payload structure.  This part of the contract is in the form of <b>schema</b>.  A schema is a (meta) data structure that describes the "shape" of other data structure.  There are two goals in mind for the use of a schema:
</p>

<dl class="org-dl">
<dt>validation</dt><dd>a schema may be used to check if a given data structure, aka "object" aka <b>model</b>, obeys the contract defined by the schema.</dd>
<dt>generation</dt><dd>a schema may be applied to a <b>template</b> in order to generate a <b>representation</b>, usually in a source code language (C++/Python) but also documentation, diagram markup language, etc.</dd>
</dl>

<p>
For practical reasons, we want to represent a conceptual or abstract schema in two (or more) different forms.  For example, JSON Schema vocabulary is well suited for validation schema while Avro Schema is well suited for generation schema.
</p>

<p>
We would like to avoid manually crafting and keeping consistent two (or more) separate representations.  To save us, moc provides sets of Jsonnet functions.  Each set returns fundamental schema data structure of a particular vocabulary (eg, JSON Schema or Avro schema).  A developer of a moc configuration may then write a set of high level functions parameterized by a fundamental function set and then structures in all supported schema vocabulary may be generated.
</p>

<p>
This may seem complex but in practice it is simple as described in the example in the next section.
</p>
</div>
</div>

<div id="outline-container-example-schema" class="outline-3">
<h3 id="example-schema">Example schema</h3>
<div class="outline-text-3" id="text-example-schema">
<p>
A simple example makes this clear.  As described above, moc reserves a set of message type hints.  We may define schema for this simple frame like:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #73d216;">// access schema primitive functions</span>
<span style="color: #b4fa70;">local</span> moc = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moc.jsonnet"</span>;
{
    schema(s):: {
        hint: s.enum(<span style="color: #e9b96e;">"Hint"</span>, [<span style="color: #e9b96e;">"JSON"</span>,<span style="color: #e9b96e;">"BSON"</span>,<span style="color: #e9b96e;">"CBOR"</span>,<span style="color: #e9b96e;">"UBJS"</span>,<span style="color: #e9b96e;">"MSGP"</span>,
                              <span style="color: #e9b96e;">"JSNT"</span>,<span style="color: #e9b96e;">"AVRJ"</span>,<span style="color: #e9b96e;">"AVRB"</span>,<span style="color: #e9b96e;">"PBUF"</span>]),
    },

    base: <span style="color: #b4fa70;">self</span>.schema(moc.base).hint,
    avro: <span style="color: #b4fa70;">self</span>.schema(moc.avro).hint,
    jscm: <span style="color: #b4fa70;">self</span>.schema(moc.jscm).hint,
    tmpl: {
        namespace: <span style="color: #e9b96e;">"moc"</span>,
        types: [ $.avro ],
    },

    data: <span style="color: #e9b96e;">"JSON"</span>,

}
</pre>
</div>

<p>
With the above, <code>moo</code> can validate that <code>data</code> is correct against <code>jscm</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s moc/simple.jsonnet -S jscm -D data moc/simple.jsonnet
</pre>
</div>

<pre class="example">
null
</pre>

<p>
The null means no error.
</p>

<p>
We may use <code>moo</code> to compile the <code>avro</code> structure to an Avro schema JSON file and generate code:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P avro moc/simple.jsonnet &gt; simple.json
avrogencpp -n moc -i simple.json -o simple_avro.hpp
grep -m1 -A10 Hint: simple_avro.hpp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #b4fa70;">enum</span> <span style="color: #b4fa70;">class</span> <span style="color: #8cc4ff;">Hint</span>: <span style="color: #8cc4ff;">unsigned</span> {
    <span style="color: #fcaf3e;">JSON</span>,
    <span style="color: #fcaf3e;">BSON</span>,
    <span style="color: #fcaf3e;">CBOR</span>,
    <span style="color: #fcaf3e;">UBJS</span>,
    <span style="color: #fcaf3e;">MSGP</span>,
    <span style="color: #fcaf3e;">JSNT</span>,
    <span style="color: #fcaf3e;">AVRJ</span>,
    <span style="color: #fcaf3e;">AVRB</span>,
    <span style="color: #fcaf3e;">PBUF</span>,
};
</pre>
</div>

<p>
In that header is more generated code to serialize this <code>enum</code> via the Avro codec.  moc may provide methods to transparently select that codec based on the "hint" being <code>AVRJ</code> or <code>AVRB</code>.
</p>

<p>
moc also supports <code>nlohmann::json</code> family of codecs to support the remaining hints besides <code>PBUF</code>.  With a suitable template file and the info supplied in the model by the <code>tmpl</code> attribute, <code>moo</code> can generate the needed code like:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo render -P tmpl moc/simple.jsonnet moc/avro_nljs.hpp.j2 &gt; simple_nljs.hpp
grep -m1 -A10 ENUM simple_nljs.hpp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">NLOHMANN_JSON_SERIALIZE_ENUM( Hint, {
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::JSON, <span style="color: #e9b96e;">"JSON"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::BSON, <span style="color: #e9b96e;">"BSON"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::CBOR, <span style="color: #e9b96e;">"CBOR"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::UBJS, <span style="color: #e9b96e;">"UBJS"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::MSGP, <span style="color: #e9b96e;">"MSGP"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::JSNT, <span style="color: #e9b96e;">"JSNT"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::AVRJ, <span style="color: #e9b96e;">"AVRJ"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::AVRB, <span style="color: #e9b96e;">"AVRB"</span> },
        { <span style="color: #e9b2e3;">moc</span>::<span style="color: #e9b2e3;">Hint</span>::PBUF, <span style="color: #e9b96e;">"PBUF"</span> },
    })
</pre>
</div>

<p>
Where this snippet shows how we ultimately rely on a CPP macro provided by <code>nlohmann</code> to generate codec.  This produces <code>to_json()</code> and <code>from_json()</code> type functions.
</p>
</div>
</div>

<div id="outline-container-payload-schema" class="outline-3">
<h3 id="payload-schema">Payload schema</h3>
<div class="outline-text-3" id="text-payload-schema">
<p>
The simple example above may be considered also an example of a trivial payload body schema.  However, a payload schema will typically be rather more complex.  It will be built from various primitive schema types as well as built up further upon types it defines itself.  For example, consider a schema describing the simple object example from <a href="https://github.com/nlohmann/json/#arbitrary-types-conversions">nlohmann::json</a> documentation:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moc = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moc.jsonnet"</span>;

{
    schema(s) :: {
        <span style="color: #b4fa70;">local</span> name = s.string(pattern=<span style="color: #e9b96e;">'^[a-zA-Z ]$'</span>),
        <span style="color: #b4fa70;">local</span> address = s.string(pattern=<span style="color: #e9b96e;">'^[a-zA-Z0-9 ]$'</span>),
        <span style="color: #b4fa70;">local</span> age = s.number(<span style="color: #e9b96e;">"i4"</span>, {minimum:0}),
        <span style="color: #b4fa70;">local</span> person = s.record(<span style="color: #e9b96e;">"Person"</span>, [
            s.field(<span style="color: #e9b96e;">"name"</span>, name),
            s.field(<span style="color: #e9b96e;">"address"</span>, address),
            s.field(<span style="color: #e9b96e;">"age"</span>, age)
        ]),
        ret: person,
    }.ret,

    base: <span style="color: #b4fa70;">self</span>.schema(moc.base),
    avro: <span style="color: #b4fa70;">self</span>.schema(moc.avro),
    jscm: <span style="color: #b4fa70;">self</span>.schema(moc.jscm),


}
</pre>
</div>

<p>
The fundamental types provided by moo are an amalgamation of those named by Avro and JSON Schema: <code>boolean</code>, <code>string</code>, <code>number</code>, <code>array</code> of a type and <code>record</code> aggregating a number of <code>field</code> elements, each of a type.  
</p>
</div>
</div>

<div id="outline-container-intra-message" class="outline-3">
<h3 id="intra-message">Intra-message Schema</h3>
<div class="outline-text-3" id="text-intra-message">
<p>
The message type hints reserved by moc also specify exactly one message payload frame may follow.  The intra-message schema for these types is thus specified.
</p>

<p>
Application developers are free to extend the supported hints to include message types with multiple payload frames.  They may develop schema to describe the message as a hole in terms of an array of schema.  
</p>

<p>
For example, an application may prefer define a "PEOPLE" message type which puts in each frame a <code>person</code> record as described in the example above.  An intra-message schema may then be defined as the <code>people</code> schema.  What is required in the Jsonnet is to expose more of the internal schema structure for example as:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #73d216;">// as above</span>
{
    schema(s):: {
        <span style="color: #73d216;">// [...as above omitted...]</span>
        <span style="color: #73d216;">// person</span>
        people: s.array(<span style="color: #b4fa70;">self</span>.person),
    }
    jscm: <span style="color: #b4fa70;">self</span>.schema(j.schema).people,
    avro: <span style="color: #b4fa70;">self</span>.schema(a.schema).people,
}
</pre>
</div>

<p>
Note we comment out the "return value" <code>person</code> and instead use its local definition as a type to define the returned <code>people</code>.
</p>

<p>
The same document may produce JSON Schema and Avro schema for all abstract schema:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">{
    schema(s) :: {
        <span style="color: #73d216;">// locals as above but return object of:</span>
        person: person,
        people: people,
    }
    jscm: <span style="color: #b4fa70;">self</span>.schema(j.schema),
    avro: <span style="color: #b4fa70;">self</span>.schema(a.schema),
}
</pre>
</div>

<p>
When applying either of the produced schema one has to take into account the substructure.  Eg, <code>avro.person</code> would be used to generate a <code>Person</code> object.
</p>
</div>
</div>

<div id="outline-container-inter-message" class="outline-3">
<h3 id="inter-message">Inter-message schema</h3>
<div class="outline-text-3" id="text-inter-message">
<p>
Inter-message schema may be (under) specified simply as an array of expected hints.   Or the same patterns described above may be extended to cover multiple messages as they are shown to cover multiple frames.  In other words, it may be schema all the way down.  
</p>
</div>
</div>
</div>


<div id="outline-container-org9728039" class="outline-2">
<h2 id="org9728039">Demos</h2>
<div class="outline-text-2" id="text-org9728039">
<p>
moc provides a few demo uses.  
</p>
</div>

<div id="outline-container-org1837da8" class="outline-3">
<h3 id="org1837da8">Install prerequisites</h3>
<div class="outline-text-3" id="text-org1837da8">
<p>
The demo requires:
</p>

<ul class="org-ul">
<li>the <code>moo</code> Python command line program in <code>$PATH</code></li>
<li>the Avro C++ library and <code>avrogencpp</code> in <code>$PATH</code></li>
<li><code>make</code>, compiler, etc</li>
</ul>
</div>
</div>

<div id="outline-container-run-the-demo" class="outline-3">
<h3 id="run-the-demo">Run the demo</h3>
<div class="outline-text-3" id="text-run-the-demo">
<p>
The demos can be built and exercised with:
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #e090d7;">cd</span> moc &amp;&amp; make clean all
</pre>
</div>

<pre class="example">
rm -f demo demo.log demo-config.json node_avro.hpp demo_avro.hpp node_nljs.hpp demo_nljs.hpp
moo compile -P avro node.jsonnet &gt; node_avro.json
avrogencpp -n moc -i node_avro.json -o node_avro.hpp
moo compile -P avro demo.jsonnet &gt; demo_avro.json
avrogencpp -n moc -i demo_avro.json -o demo_avro.hpp
moo render -P nljs node.jsonnet avro_nljs.hpp.j2 &gt; node_nljs.hpp
moo render -P nljs demo.jsonnet avro_nljs.hpp.j2 &gt; demo_nljs.hpp
g++  -ggdb3 -std=c++17 -Wall -o demo demo.cpp \
           -I ../inc -I. -I/home/bv/opt/avro/include -L/home/bv/opt/avro/lib -lavrocpp -Wl,-rpath=/home/bv/opt/avro/lib
moo compile --string -P demo.stream demo.jsonnet &gt; demo-config.json
./demo demo-config.json &gt; demo.log
cat demo.log
Factory: MySource instance mysource1
Creating new SourceComponent
SourceComponent mysource1 configuring
	ntosend = 10
Factory: Node instance mynode1
Creating new Node
Config for moc::Node ID: "mynode1"
	node port ID: "src"
		link type:0 address:""
	node comp type "MySource" instance "mysource1" wants port IDs: "src"
		instance config: "MySource::mysource1 config string"
Factory: MySource instance mysource1
Have MySource instance mysource1
Source mysource1 using ports: src
configure done
rm node_avro.json demo_avro.json
</pre>

<p>
This automatically does the following:
</p>

<ul class="org-ul">
<li>generates schema objects from Jsonnet</li>
<li>applies those schema objects to generate Avro schema files</li>
<li>generates C++ classes with Avro's C++ generator</li>
<li>augments the C++ classes with functions to serialize to/from <code>nlohmann::json</code></li>
<li>builds a demo <code>main()</code> program with generated and hand-written code.</li>
<li>produces schema-compliant configuration objects as JSON stream files</li>
<li>runs the demo to process the streams using moc's C++ support code</li>
</ul>
</div>
</div>

<div id="outline-container-demo-framework" class="outline-3">
<h3 id="demo-framework">Demo framework</h3>
<div class="outline-text-3" id="text-demo-framework">
<p>
The demo utilizes a simple application framework called <b>moc node</b> which mocks up (really, mocks down) a full featured implementation found as <a href="https://brettviren.github.io/zio/node.html">ZIO node</a>.  It is used to provide a realistic target for configuration.  moc node differs from ZIO node in that the factory/plugin pattern is fake and no actual port initialization, discovery, auto-connect or other ZIO mechanisms are implemented.  Instead, the demo constructs via the fake factory and applies configuration merely by printing out its values.
</p>

<p>
Nonetheless, the moc node framework is faithful to the type of configuration complexity that would be required to use ZIO node or similar application aggregation concepts.  The demo application is deconstructed into these parts:
</p>

<dl class="org-dl">
<dt>node</dt><dd>represents a unit of functionality to the system and is composed of <b>ports</b> and <b>components</b></dd>
<dt>port</dt><dd>an abstraction of a message passing socket.  It is through ports that a node, via its <b>components</b> interacts with the outside world.</dd>
<dt>component</dt><dd>a unit of application functionality.  Components may use and share zero or more ports created by the node.</dd>
</dl>

<p>
Components instances are addressed by a pair of names as strings: type or implementation name and instance name.  In C++ code, an instance is held by an abstract base class aka an interface class.  In a real framework, a factory/plugin method would be used to dynamically local code for a component from a set of shared libraries and dynamically construct and later allow lookup of instances.  The moc demos will fake that but the (implementation,instance) name pairs are still used in the configuration.
</p>

<p>
Given this deconstruction, any number of nodes may be created in the <code>demo</code> main program and in each node any number of components may be created.  Each node "makes" a number of ports, handles their (fake) bind/connect and is told which components wish to utilize which ports.  This is all driven by configuration which itself is governed by schema.
</p>
</div>
</div>

<div id="outline-container-orgb0fc9bc" class="outline-3">
<h3 id="orgb0fc9bc">Demo details</h3>
<div class="outline-text-3" id="text-orgb0fc9bc">
<p>
This section highlights some of the details in the code.  First
the <a href="moc/Makefile">Makefile</a> drives the entire demo and then the <a href="moc/demo.cpp">demo.cpp</a> <code>main()</code> program.
</p>
</div>

<div id="outline-container-orgf228afe" class="outline-4">
<h4 id="orgf228afe">Makefile driver</h4>
<div class="outline-text-4" id="text-orgf228afe">
<p>
The demo uses a Makefile to automate the demo.  The source is a few Jsonnet files, a hand-written header and a hand written <code>main()</code>.  All the rest is generated.
</p>

<p>
To start, we directly compile Jsonnet structure to AVRO schema JSON and run the <code>avrogencpp</code> program to generate C++ header files defining C++ structs which will match our configuration objects.  We take the convention to put these generated files in <code>&lt;name&gt;_avro.hpp</code> where the name may be <code>node</code> for common "framework" classes and <code>demo</code> for application classes:
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A4 demo:AVRO moc/Makefile
</pre>
</div>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #73d216;"># </span><span style="color: #73d216;">demo:AVRO schema and generate C++ </span>
<span style="color: #fce94f;">%_avro.json</span>: %.jsonnet 
        moo compile -P avro $<span style="color: #e9b2e3;">&lt;</span> &gt; <span style="color: #fce94f;">$</span><span style="color: #e9b2e3;">@</span>
<span style="color: #fce94f;">%_avro.hpp</span>: %_avro.json
        $(<span style="color: #fcaf3e;">AVROGENCPP</span>) -n $(<span style="color: #fcaf3e;">namespace</span>) -i $<span style="color: #e9b2e3;">&lt;</span> -o <span style="color: #fce94f;">$</span><span style="color: #e9b2e3;">@</span>
</pre>
</div>

<p>
Next, we directly apply another part of the Jsonnet structures via <code>moo</code> to a template to generate <code>nlohmann::json</code> (NLJS) serialization functions for the Avro classes.  
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A2 demo:NLJS moc/Makefile
</pre>
</div>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #73d216;"># </span><span style="color: #73d216;">demo:NLJS generated C++ </span>
<span style="color: #fce94f;">%_nljs.hpp</span>: %.jsonnet avro_nljs.hpp.j2 
        moo render -P nljs $<span style="color: #e9b2e3;">^</span> &gt; <span style="color: #fce94f;">$</span><span style="color: #e9b2e3;">@</span>
</pre>
</div>

<p>
Last we show how one particular configuration may be generated.  In a real system we might keep the Jsonnet files for configuration separate from code generation, maybe managed in <code>git</code>.  Or, some configuration information may start as Jsonnet or other forms, go into some "database" and be derived to form the JSON or SHFM streams.
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A2 demo:config moc/Makefile
</pre>
</div>

<div class="org-src-container">
<pre class="src src-makefile"><span style="color: #73d216;"># </span><span style="color: #73d216;">demo:config generated configuration data</span>
<span style="color: #fce94f;">demo-config.json</span>: demo.jsonnet
        moo compile --string -P demo.stream demo.jsonnet &gt; demo-config.json
</pre>
</div>

<p>
Note the use of <code>--string</code> which produces a JSON Stream format instead of a JSON array.
</p>
</div>
</div>

<div id="outline-container-org9b6a5af" class="outline-4">
<h4 id="org9b6a5af">Mock application</h4>
<div class="outline-text-4" id="text-org9b6a5af">
<p>
The file <a href="moc/demo.cpp">demo.cpp</a> holds code to fake an entire software application framework and fakes several services and application level components.  Let us start in <code>main()</code> with creation of the configuration stream:
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A3 demo:main moc/demo.cpp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">demo:main</span>
<span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">ifstream</span> <span style="color: #fce94f;">fstr</span>(streamname);
<span style="color: #e9b2e3;">moc</span>::<span style="color: #8cc4ff;">type_stream</span> <span style="color: #fcaf3e;">ts</span> = <span style="color: #e9b2e3;">moc</span>::make_type_stream(fstr, streamtype);
do_configure(ts);
</pre>
</div>

<p>
In a real application we might hide the details of where the bytestream comes from by placing this code in a configuration manager and have different manager for, eg files as ZeroMQ messages.  Next we see <code>do_configure()</code>:
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A16 do_configure moc/demo.cpp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">do_configure</span>(<span style="color: #e9b2e3;">moc</span>::<span style="color: #8cc4ff;">type_stream</span>&amp; <span style="color: #fcaf3e;">ts</span>)
{
    <span style="color: #b4fa70;">while</span> (<span style="color: #e9b2e3;">true</span>) {
        <span style="color: #e9b2e3;">moc</span>::<span style="color: #8cc4ff;">ConfigHeader</span> <span style="color: #fcaf3e;">ch</span>;
        <span style="color: #b4fa70;">try</span> {
            ch = ts.pop&lt;<span style="color: #e9b2e3;">moc</span>::<span style="color: #8cc4ff;">ConfigHeader</span>&gt;();
        }
        <span style="color: #b4fa70;">catch</span> (<span style="color: #e9b2e3;">std</span>::runtime_error(re)) {
            <span style="color: #73d216;">// </span><span style="color: #73d216;">fixme: mock: find a less dramatic way to signal end of stream</span>
            <span style="color: #e9b2e3;">std</span>::cout &lt;&lt; <span style="color: #e9b96e;">"configure done\n"</span>;
            <span style="color: #b4fa70;">return</span>;
        }

        <span style="color: #b4fa70;">auto</span>&amp; <span style="color: #fcaf3e;">ic</span> = fake_factory&lt;IConfigurable&gt;(ch.impname, ch.instname);
        ic.configure(ch.instname, ts);
    }
}
</pre>
</div>

<p>
Here we see how the <code>moc::type_stream</code> can "retype" the underlying byte stream using the generated. Avro classes and NLJS serialization functions. 
</p>

<p>
The <code>do_configure()</code> enacts a particular protocol for applying the configuration stream to the application.  This is an example of an <b>inter-message schema</b> described above.  It requires message stream come with messages like
</p>

<ol class="org-ol">
<li><code>ConfigHeader</code></li>
<li>configuration body</li>
<li><code>ConfigHeader</code></li>
<li>configuration body</li>
<li>&#x2026;</li>
</ol>

<p>
The <code>moc::ConfigHeader</code> is ultimately defined by:
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A1 ConfigHeader moc/demo.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> cfghdr = s.record(<span style="color: #e9b96e;">"ConfigHeader"</span>, fields=[
    s.field(<span style="color: #e9b96e;">"impname"</span>, ident), s.field(<span style="color: #e9b96e;">"instname"</span>, ident)]),
</pre>
</div>

<p>
And, it is the  <b>implementation name</b> (<code>impname</code>) and <b>instance name</b> (<code>instname</code>) which are used by the factory method in <code>demo.cpp</code> to look up an appropriate instance to consume the subsequent <b>configuration body</b>.
</p>

<p>
The first configuration in the demo goes to an instance of a <code>SourceComponent</code> named <code>mysource1</code>.  It's not a very interest class but just not that it is configured first.  The next configurable is a <code>Node</code> instance.  <code>Node</code> is considered a "framework" level class while <code>SourceComponent</code> may be a class provided in a plugin library.  In ZIO a "node" would be an atomic unit "known" to the outside world via ZeroMQ sockets and Zyre discovery.  Most likely we will have one node for each executable, but there is no technical limitation.
</p>

<p>
The moc demo node is useful to look at to see how it also uses the factory to get an interface to a component so that it may pass on <b>port</b> objects.  In the demo, ports are simply strings.  In equivalent ZIO code, ports hold sockets which are bind/connect via configuration.
</p>

<div class="org-src-container">
<pre class="src src-shell">grep -m1 -A3 demo:lookup moc/demo.cpp
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">    <span style="color: #73d216;">// </span><span style="color: #73d216;">demo:lookup</span>
    <span style="color: #b4fa70;">auto</span>&amp; <span style="color: #fcaf3e;">ip</span> = fake_factory&lt;IPorted&gt;(compcfg.type_name, compcfg.ident);
    ip.set_ports(ps);
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Viren</p>
<p class="date">Created: 2020-06-12 Fri 16:34</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
