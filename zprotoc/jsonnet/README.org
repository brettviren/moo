* Model Taxonomy

Before we model, we must model the model.  Our eventual model is a
data structure which follows a particular object schema.  That data
structure will eventually describes all the parts that go into a
"protocol endpoint" and so the schema it follows is described in term
of the "taxonomy of protocol endpoints".  We don't know what the heck
a "taxonomy of protocol endpoints" is, but that shouldn't stop us from
creating it.

But, first we must say that the data structure which is our model will
be rather annoying to write out in long hand.  Thus we will model our
model in Jsonnet.  So this section is really modeling a model of our
model.  This is of course ridiculous (despite being true).  To keep it
simple, moo gives us some Jsonnet functions and data structures to use
when constructing model that forces the resulting data structure to be
well formed.  In fact, it is these functions that define the schema
which our templates must finally honor.


** Basic types

Eventually our model will be applied a template to generate code.
Most code needs to include some type names so we must be able to name
types.  In moo we do that like:

#+begin_src jsonnet
  local lang = import "moo/cpp.jsonnet";
  lang.types.string
#+end_src

Which returns:

#+begin_src c++
  "std::string"
#+end_src

A moo type is simply the name of some type in the target programming
language stored in a Jsonnet variable which itself evokes the type
name.  The Jsonnet variable name is consistent across all target
variables.  Eg,

#+begin_src jsonnet
  local lang = import "moo/python.jsonnet";
  lang.types.string
#+end_src

Returns

#+begin_src c++
  "str"
#+end_src

There are similar basic types defined for all your plain-old-data
needs.  If any are missing, well, we can add them.  

But, before we leave basic types there is one type which is not a type
and that is ~notype~ which in C++ gives our friend, ~void~.

** Attributes

It is sometimes not enough to simply name a type and we often must
name a thing.  A named thing in moo is an attribute.  An attribute of
what?  Who knows? (Well, we do, but we do not yet say).

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  moo.attribute("color", lang.types.string, "purple")
#+end_src

Returns:

#+begin_src json
{
   "def": "purple",
   "name": "color",
   "type": "std::string"
}
#+end_src

So, an attribute has a type, a name and a default (~"def"~) value of the
given type.  It is fun to talk about one attribute here and one
attribute there but sometimes we want more than one.  When we have
many attributes we simply have an array of attribute.

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  [
    moo.attribute("color", lang.types.string, "purple"),
    moo.attribute("count", lang.types.integer, 0),
  ]
#+end_src

This compiles to:

#+begin_src json
  [
     {
        "def": "purple",
        "name": "color",
        "type": "std::string"
     },
     {
        "def": 0,
        "name": "count",
        "type": "int"
     }
  ]
#+end_src

These JSON examples are getting long and already Jsonnet's brevity is
being appreciated.

** Object

Our next scale up in complexity is on the one hand rather simple.  We
combine a "name" with some attributes and call it an "object".  The
"name" we will interpret kind of like a type.

In fact, in some cases, we interpret it exactly like a type.  Some
templates will generate a target language ~struct~ or ~class~ type from a
model object.  Others will generate a message schema or generate code
that can make messages where the "name" is held by the message as a
type identifier.

We will also add an optional element of ~object~ which is a brief
documentation string called ~help~.

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  moo.object("candies", [
    moo.attribute("color", lang.types.string, "purple"),
    moo.attribute("count", lang.types.integer, 0),
  ], "A container full of yumminess")
#+end_src

We'll omit the JSON as it's no long exciting to see all those curly
braces and quotes.  The JSON object representation of ~object~ is not
particularly important until we learn about writing templates but
~.name~ givs us the name, ~.attrs~ gives the array of attributes and ~.help~
gives us the help string.

Let's think more about our ~object~.  It models a compound of types and
has a name that is kind of a type, but not really.  The name just
identifies the type.  The ~object~ as a whole is the type.  Just like in
C++ the ~struct~ name is not a type it just names a type.  Okay, so then
shouldn't we be able to make an object with attributes that are
themselves objects?  Let's not ask for permission.  Let's just do it:

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  local candies = moo.object("candies", [
      moo.attribute("color", lang.types.string, "purple"),
      moo.attribute("count", lang.types.integer, 0),
  ]);
  moo.object("eat", [
      moo.attribute("snack", candies),
  ])
#+end_src

Well, that at least compiles to JSON.  We omitted the "help" for
brevity.  We also did not give a default value for the ~"eat"~ object
which holds a single ~attribute~ which is an ~object~.  What sort of
default can we give since we are modeling and not generating code?
The answer is none, so we give none.  Templates that use the model can
still make a default from an ~object~ as each attribute (which isn't an
~object~) provide a default.

** Method

We say a "method" is a function called on an associated "instance".
The call possibly has some arguments, each of a type and possibly
returns a value of a type.  

In moo we could model a ~method~ similar to an ~object~.  The ~name~ of the
~object~ could be the name of the method, the attributes of the object
could be the arguments.  

But whence the return value and type?  We could model the ~method~ as an
attribute.  Then we have the name, and the return value and type.
But, now we've lost arguments (I hate losing arguments).

We could make a special attribute of an ~object~ describe the return
type but that feels too invasive and level smashing (I hate layer
smashing).

So we make a new model for a method which smooshes the two together.
But we still note that the resulting ~method~ data structure looks a
whole lot like an ~attribute~ or an ~object~.

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  moo.method("open", lang.types.boolean, false, [
      moo.attribute("door", lang.types.string),
      moo.attribute("code", lang.types.integer, 1234)],
             "Open a door with a code, return true if successful")
#+end_src

We also see that the beauty of a ~method~ is, at best, skin deep.
Except for the parts in ~lang~ which are target-language-specific, we
have no way to specify the "guts" of the method.  If there are any
guts to serve at all, it is up to the templates to do that carving.

** State Machine

The next model type is itself its own little world as moo has for
modeling (hierarchical) finite state machines (FSM - not flying
spaghetti monster).  If you do not know what FSMs are, go read
[[https://en.wikipedia.org/wiki/Finite-state_machine][wikipedia]].  Go on, I'll wait.

Back already?  Fascinating stuff, wasn't it.  As you learned, FSMs
have a few interrelated parts and thus their modeling requires a few
interrelated models.  

SM are important to the great protocol endpoint taxonomy that we
endeavor to one day define.  As programmers, we write SMs all the time
without knowing it.  On the street they are called "an ugly mess of
if/then/else and sometimes goto".  But in the pristine halls of
academia (if I was still allowed in) we come up with names for messes
and call it science.  So, "hierarchical finite state machine" it is.
And, in fairness, modeling the mess of branching we ultimately always
need gives us an excellent way to disentangle that mess and approach
something that might resemble beauty.

In moo we already know all the models we need to construct a model of
an FSM.  Here are the

- event :: ~object~ 
- guard :: ~method~ (returning boolean)
- action :: ~method~ (returning null)
- state :: ~object~ (likely devoid of attributes)
- transition :: two states and optional event, guards and actions
- context :: ~object~ some contextual data accessible to guards and actions and the larger context calling the state machine
- machine :: ~object~ with at least one attribute named ~tt~ holding array of transitions and a ~context~ attribute.  A machine may also be used where a state is used and that's what lets us use the fancy word "hierarchical".


#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  local lang = import "moo/cpp.jsonnet";
  local string = lang.types.string;
  local boolean = lang.types.boolean;
  // events
  local start = moo.object("start", [moo.attribute("greeting", string, '""')]);
  local quit = moo.object("quit");
  // states
  local ini = moo.object("initializing");
  local wrk = moo.object("working");
  local fin = moo.object("finalizing");
  // guards
  local awake = moo.method("check_awake", boolean, false);
  local happy = moo.method("check_happy", boolean, false);
  // actions
  local dowork = moo.method("dig_that_hole", lang.types.notype);
  // transition table
  local tt = [
      moo.transition(ini,wrk,start,[awake,happy],[dowork]),
      moo.transition(wrk,fin,quit)
  ];
  local ctx = moo.object("gear", [ moo.attribute("lunch", string, '"sandwich"'),
                                   moo.attribute("tool", string, '"hammer"') ]);
  local worksm = moo.object("work", [ moo.attribute("tt", tt),
                                      moo.attribute("context", ctx) ]);
  worksm
#+end_src

Modeling FSMs in moo requires embracing some caveats.  Ultimately the
FSM implementation depends on how the template interprets the model.
This is true for all moo models and templates but it's extra true for
FSMs.  The FSM model may turn into a nest of ~if/then/else~ branches or
the use of the ~tt~ may turn into a literal lookup into a transition
table.  The instance of the ~context~ model may be explicitly passed
into guards and actions or it may be "global".  In a likewise or
different fashion the current event instance may be made available to
these methods.  When we model the FSM we must know what data can be
shared between the FSM parts but the model doesn't specify how it is
shared, or even that it is shared, the template does.  

This unfortunately produces a conceptual cycle between the model and
the template.  Your humble author apologizes but I squeak a defense
that to further specify the FSM in the model would limit how it may be
implemented to the extent that the model would hold implementation
code and break my promise that modeling does not require programming.

** Command

We now start to get out of the low level world of navel gathering on
basic data structures and up our game to begin navel gathering on the
mythical "protocol endpoint taxonomy".

One of the most basic protocols is a back and maybe a forth exchange
between two entities.  I tell you to jump, you say how high.  Or,
maybe you simply ignore me.  Or, maybe you laugh in my face.  However
it may play out, moo calls this exchange a "command" and we model it
with a ~command~.

A command models something very much like a method.  You call an
instance of a method and that may return you value.  The ~name~ and
~arguments~ to a ~command~ instance may form an ~object~ and we will think
of that ~object~ as modeling a message sent to the other endpoint.

That part is easy.  It's always easier to shout into the abyss.  It's
harder to know what to do with the abyss answers.  Many types of
messages may come back and we'd like to model the behavior the command
enacts as a reaction.  Thankfully we just spent a section talking
about how to model behavior and so we will use an FSM model.

Lastly, we have that return value to deal with.  At most the ~command~
model can give the type and default value for the return.  The
template may collude with the model of the actions of the FSM to
effect a return or throw an exception.

This again brings us dangerously close to actual programming while it
was promised by moo (or rather by me) that we will slipped those
shackles.  It's also getting dangerously close to smashing layers
which someone recently claimed to hate.  Nonetheless we will try to stay true to our word.

Let's start by seeing how to construct a command model.

#+begin_src jsonnet
  local met = moo.method("open",...);
  local sm = moo.machine( ... );
  moo.command(met, sm, "Tell someone to open a door")
#+end_src

Well, that looks simple.  I see a method.  I know what that is.  I see
what looks like a help string.  That's nice and friendly.  And, I see
an FSM model.  No worries.

** Endpoint 

An endpoint there means one end if a protocol conversation and
~endpoint~ models it.  The "point" of an endpoint should be considered
to live in isolation only reacting to input by producing output.

** API

An API models a number of commands that govern a captive endpoint.
For example, an API template may generate an API class which
application will instantiate and through its methods it will send
command messages into an endpoint FSM and get back responses.  That
FSM may also be handling messages from the cosmos.



* Templates

In moo, templates are files in some nominal format but with extra
template markup sprinkled around.  When a template compiler applies a
data structure a new file in the nominal format is generated.  There
are many template systems and you can use different ones while still
using moo models.

But, in moo we'll focus on Jinja2 templates.  There are many ways to
use Jinja2 to apply data to templates but we will stick with the
simplicity of using the ~j2~ command line program.  You can install it
from PyPI like:

#+begin_example
  $ pip install j2cli
#+end_example

** Getting started

Before we get "serious" let's look at a trivial example.  First, a C++
template file:

#+include: examples/hello-types.hpp.j2 src c++

And a simple model file:

#+include: examples/hello-types.jsonnet src jsonnet

We compile the template against the model with ~j2~ and get a C++ file
out:

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  j2 -f json examples/hello-types.hpp.j2 <(jsonnet -J . examples/hello-types.jsonnet) | clang-format
#+end_src

#+RESULTS:
#+begin_SRC c++
/*
 ,* Known types:
 ,*
 ,* - boolean
 ,* - integer
 ,* - notype
 ,* - string
 ,*/

#ifndef HELLO_MYTYPE
#define HELLO_MYTYPE

namespace hello {

    struct MyType {
        int x = 0;
        std::string s = "";
    };

    void to_json(json& j, const person& p) { j = json{{"x", p.x}, {"s", p.s}}; }

    void from_json(const json& j, person& p) {
        j.at("x").get_to(p.x);
        j.at("s").get_to(p.s);
    }
}  // namespace hello
#endif
#+end_SRC

It's possible to fuss over the Jinja2 templates in order to get
formatting just the way you like it.  For C++ it may be simpler to let
~clang-format~ to that work.  For the rest of this section we will walk
through some of the batteries-included templates provided by moo.

