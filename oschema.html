<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-01-19 Tue 13:45 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title><code>moo</code> 無 <code>oschema</code></title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Brett Viren" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="other/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="other/readtheorg/css/readtheorg.css"/>
<script type="text/javascript" src="other/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="other/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="other/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="other/readtheorg/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style> p{max-width:800px;}</style>
<style> li{max-width:800px;}</style>
<style> pre.src{border-radius: 5px; background-color:#333; color:#0f0;}</style>
<style> pre.example{border-radius: 5px; background-color:#333; color:#0f0;}</style>
<style> code{border-radius: 5px; background-color:#333; color:#0f0;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title"><code>moo</code> 無 <code>oschema</code>
<br />
<span class="subtitle">Describing schema as objects</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#concepts">Concepts</a></li>
<li><a href="#Schema">Schema</a>
<ul>
<li><a href="#schema-in-jsonnet">Jsonnet</a></li>
<li><a href="#schema-in-python">Python</a></li>
</ul>
</li>
<li><a href="#transforms">Models</a>
<ul>
<li><a href="#diy-trans">DIY</a></li>
<li><a href="#jsonnet-tla-trans">Jsonnet</a></li>
<li><a href="#python-trans">Python</a></li>
</ul>
</li>
<li><a href="#codegen">Codegen</a>
<ul>
<li><a href="#model">Model</a></li>
<li><a href="#struct">Template</a></li>
</ul>
</li>
<li><a href="#objects">Objects</a></li>
</ul>
</div>
</div>

<div id="outline-container-concepts" class="outline-2">
<h2 id="concepts">Concepts</h2>
<div class="outline-text-2" id="text-concepts">
<p>
In general, a <b>schema system</b> (aka meta schema) defines ways in which we
may define <b>schema</b>.  Each schema describes one or more <b>types</b>.  And each
type in turn defines the allowed structure and constraints of <b>models</b>
(aka "values").  <b>moo</b> supports a number of schema systems but the
dominant one is <i>oschema</i>.
</p>

<div class="note" id="org6a142ba">
<p>
The "o" stands for "object" as <i>oschema</i> describes a type using an
object representation.  A lesser used <b>moo</b> schema system is <i>fschema</i>
which as you may guess uses a functional representation.
</p>

</div>

<p>
Many schema systems will specify a persistent representation (file
format) for expressing a schema.  Eg, XML has XSD and JSON has JSON
Schema (itself expressed as JSON).  <b>moo</b> <i>oschema</i> system is defined
in terms of a transient representation (structured data in memory).
Thus, a large number of persistent representations may be used to
provide <i>oschema</i> schema.  Users may select file formats they know and
love if they wish.  Below we will describe two (Jsonnet and Python).
</p>

<p>
<b>moo</b> <i>oschema</i> is defined conceptually starting with a fixed set of
<b>schema classes</b> that are listed below.  A <b>moo</b> <i>oschema</i> <b>type</b>
(called in some parts of <b>moo</b> an <i>otype</i>) is considered an instance
of exactly one <b>schema class</b>.  Dropping down one rung of the semantic
ladder, a <b>model</b> (aka "value") is an instance of a <b>type</b>.
</p>

<p>
The <b>moo</b> <i>oschema</i> schema classes are:
</p>

<dl class="org-dl">
<dt><code>boolean</code></dt><dd>a type which may take value "true" or "false"</dd>
<dt><code>number</code></dt><dd>a numeric type of given format and size</dd>
<dt><code>string</code></dt><dd>a character string type possibly matching some pattern or format</dd>
<dt><code>sequence</code></dt><dd>an array or vector with elements of one type</dd>
<dt><code>tuple</code></dt><dd>(not yet supported, but you can guess what it will be)</dd>
<dt><code>record</code></dt><dd>a collection of named types, (eg such as a <code>class</code> or <code>struct</code>)</dd>
<dt><code>enum</code></dt><dd>a type that may take one value from a predefined, limited set of values</dd>
<dt><code>any</code></dt><dd>a type that may take a value of any type (eg such as <code>void*</code>, <code>boost::any</code>, <code>nlohmann::json</code>)</dd>
<dt><code>anyOf</code></dt><dd>a type that may take a value of any type in a predefined, limited set of types.</dd>
<dt><code>namespace</code></dt><dd>a collection of named types, (distinct from <code>record</code> to match eg C++/Python semantics)</dd>
</dl>

<p>
Every <i>oschema</i> <b>type</b> then provides a set of <b>attributes</b> as
determined by its schema class.  Some attributes are common across all
schema classes and may be required or optional:
</p>

<dl class="org-dl">
<dt><code>name</code></dt><dd>(required) type name unique to the type context (see <code>path</code>)</dd>

<dt><code>schema</code></dt><dd>(required) string identifying the schema class taken from above list</dd>

<dt><code>doc</code></dt><dd>(optional, default empty) document string briefly describing the type</dd>

<dt><code>path</code></dt><dd>(required, potentially empty), ordered array of names
representing the absolute context of the type (eg as a C++
<code>namespace</code> or Python module path).</dd>
</dl>

<p>
Some <b>types</b> must <b>reference</b> one or more other types.  These include
instances of the schema classes: <code>sequence</code>, <code>record</code>, <code>namespace</code>,
and <code>anyOf</code>.  A <b>type reference</b> is represented as a <i>fully-qualified
type name</i> (FQTN) which is formed as the dot-separated concatenation
of the elements of <code>path</code> (if any) and the <code>name</code>.  A FQTN shall not
begin nor end with a period.  As the <code>path</code> is absolute there is no
concept of a "relative" type reference.
</p>

<p>
Thus, every <b>type</b> exists at an absolutely determined location in a
name hierarchy, and it carries this location with it as <code>path</code> +
<code>name</code>.  Types that must reference another type do so by its <code>path</code>
and <code>name</code>.  Of course, to resolve a reference the referred type must
be available in order to match the type reference against possible
<code>path</code> and <code>name</code>.  For this reason a <b>schema</b> is considered
<b>complete</b> if every type referenced by any of the schema's types are
also included.
</p>
</div>
</div>



<div id="outline-container-Schema" class="outline-2">
<h2 id="Schema">Schema</h2>
<div class="outline-text-2" id="text-Schema">
<p>
This section describes how to define a schema using either the
<b>Jsonnet</b> or the <b>Python</b> programming language as a persistent
representation.  To illustrate some of the patterns seen in real,
large-scale projects the example will factor the schema into two
parts:
</p>

<dl class="org-dl">
<dt><i>sys</i></dt><dd>a set of types relevant to some system (eg a framework)</dd>
<dt><i>app</i></dt><dd>a set of types relevant to an application based on the system</dd>
</dl>
</div>

<div id="outline-container-schema-in-jsonnet" class="outline-3">
<h3 id="schema-in-jsonnet">Jsonnet</h3>
<div class="outline-text-3" id="text-schema-in-jsonnet">
<p>
<b>moo</b> <i>oschema</i> may be described easily in the
<a href="https://jsonnet.org/">Jsonnet</a> language as Jsonnet was designed for
defining data structures.
</p>

<p>
We start by simply presenting the <code>sys</code> schema:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">// examples/oschema/sys.jsonnet
local moo = import "moo.jsonnet";
local sys = moo.oschema.schema("sys");
[sys.number("Count", "u4")]
</pre>
</div>

<p>
Let's walk through this short example line by line:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local moo = import "moo.jsonnet";
</pre>
</div>

<p>
This shows Jsonnet's "module" system in action.  A file is loaded and its
contents available via the <code>moo</code> variable.  The <code>moo.jsonnet</code> file holds
various Jsonnet functions and data that will help build our <i>oschema</i>.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local sys = moo.oschema.schema("sys");
</pre>
</div>

<p>
This call of the <code>schema()</code> function of the <code>moo.oschema</code> object
returns another object held by the local variable <code>sys</code> which will
provide sort of a "schema factory" that operates "in" the type path of
"sys".  We see it in action:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">[sys.number("Count", "u4")]
</pre>
</div>

<p>
This last line defines the data structure which is the "return" value
of the entire <code>sys.jsonnet</code> file.  That is, this file "compiles" to an
array holding a single <i>oschema</i> type.
</p>

<div class="note" id="orgcac8f46">
<p>
All <b>moo</b> "schema files" are expected to provide an
array-of-type-objects.  We will later see how the order of this array
matters and how to assure it is correct.  We will also later see how
this array becomes just one element of a more complex structure called
a <b>model</b> which we will form prior to applying to a <b>template</b>.
</p>

</div>

<p>
We can see how the <i>sys</i> schema expands or compiles to a JSON
representation using <b>moo</b>:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile examples/oschema/sys.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">[
    {
        "deps": [],
        "dtype": "u4",
        "name": "Count",
        "path": [
            "sys"
        ],
        "schema": "number"
    }
]
</pre>
</div>

<p>
This is then a schema with a single type called <code>Count</code> which is of
schema class <code>number</code> that has numeric Numpy-style type code <code>dtype</code> of an
unsigned integer in four bytes <code>"u4"</code> and is in a context <code>path</code> of simply
<code>["sys"]</code>.
</p>

<div class="note" id="org0584b75">
<p>
The final structural form of <i>oschema</i> (ie, the JSON above) is not
something that a developer of a schema strictly needs to know.  <b>moo</b>
support for Jsonnet and Python provide native language code to assist
in building a schema without exposing all the details of the type
object structure.  But these details shall need to be understood if
any new native language support is developed.
</p>

</div>

<p>
Next, we imagine an application schema with a more rich set of types:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">// examples/oschema/app.jsonnet
local moo = import "moo.jsonnet";
local sa = import "sys.jsonnet";
local sh = moo.oschema.hier(sa);
local as = moo.oschema.schema("app");
local hier = {
    counts: as.sequence("Counts",sh.sys.Count,
                        doc="All the counts"),

    email: as.string("Email", format="email",
                    doc="Electronic mail address"),
    affil: as.any("Affiliation",
                  doc="An associated object of any type"),
    mbti: as.enum("MBTI",["introversion","extroversion",
                          "sensing","intuition",
                          "thinking","feeling",
                          "judging","perceiving"]),
    make: as.string("Make"),
    model: as.string("Model"),
    autotype: as.enum("VehicleClass", ["boring", "fun"]),
    vehicle : as.record("Vehicle", [
        as.field("make", self.make, default="Subaru"),
        as.field("model", self.model, default="WRX"),
        as.field("type", self.autotype, default="fun")]),

    person: as.record("Person", [
        as.field("email",self.email,
                 doc="E-mail address"),
        as.field("email2",self.email,
                 doc="E-mail address", default="me@example.com"),
        as.field("counts",self.counts,
                 doc="Count of some things"),
        as.field("counts2",self.counts,
                 doc="Count of some things", default=[0,1,2]),
        as.field("affil", self.affil,
                 doc="Some affiliation"),
        as.field("mbti", self.mbti,
                 doc="Personality"),
        as.field("vehicle", self.vehicle, doc="Example of nested record"),
        as.field("vehicle2", self.vehicle, default={model:"CrossTrek", type:"boring"},
                 doc="Example of nested record with default"),
        as.field("vehicle2", self.vehicle, default={model:"BRZ"},
                 doc="Example of nested record with default"),
    ], doc="Describe everything there is to know about an individual human"),
};
sa + moo.oschema.sort_select(hier, "app")
</pre>
</div>

<p>
We will go through some of these lines of Jsonnet in order to explain
some of the forms.  Starting with the first few lines:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local moo = import "moo.jsonnet";
local sa = import "sys.jsonnet";
local sh = moo.oschema.hier(sa);
local as = moo.oschema.schema("app");
</pre>
</div>

<p>
As with <code>sys</code> we import the support module <code>moo.jsonnet</code>.  We also import
the <i>sys</i> schema that we made above.  Thus, <code>sa</code> holds a single-element
array.
</p>

<p>
Next we call the <code>moo.oschema.hier()</code> method on this array.  This
transforms the ordered array of types into an (unordered) object where
each type is available by its name.  We'll see <code>sh</code> in use next.  
</p>

<p>
Finally for this preamble, we make another "schema factory" which is
this time "in" the path: <code>app</code>.  We'll use <code>as</code> many times to build up
elements of our schema.  
</p>

<p>
Next we build our <i>sys</i> schema and do so inside a "working object".
This lets us use Jsonnet language feature to refer to one of our types
in another.  Let's look at the start:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local hier = {
    counts: as.sequence("Counts",sh.sys.Count,
                        doc="All the counts"),
</pre>
</div>

<p>
Here we start our object and save it in a local variable <code>hier</code> and give
it an initial entry.  The key name <code>counts</code> is a temporary convenience
and the value is what will ultimately matter.  The type we make is a
sequence that references the <code>sys.Count</code> type made in the <i>sys</i> schema.
This shows how "cross schema" references can be made.
</p>

<p>
The next set of types are nothing special but illustrate how instances
of some of the different schema classes in Jsonnet are made:
</p>

<p>
Next, let's jump to the definition of the <code>Person</code> type which begins with:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">email: as.string("Email", format="email",
                doc="Electronic mail address"),
affil: as.any("Affiliation",
              doc="An associated object of any type"),
mbti: as.enum("MBTI",["introversion","extroversion",
                      "sensing","intuition",
                      "thinking","feeling",
                      "judging","perceiving"]),
</pre>
</div>

<p>
Now we define an instance of the <code>record</code> schema class:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">make: as.string("Make"),
model: as.string("Model"),
autotype: as.enum("VehicleClass", ["boring", "fun"]),
vehicle : as.record("Vehicle", [
    as.field("make", self.make, default="Subaru"),
    as.field("model", self.model, default="WRX"),
    as.field("type", self.autotype, default="fun")]),
</pre>
</div>

<p>
In addition to showing how an instance of a <code>record</code> schema class this
example shows how to reference types within our "working object"
through a <code>self</code> object.  We will skip the res of our "working object"
other than to say that this <code>Vehicle</code> type is referenced in the <code>Person</code>
type described in the remaining and that this shows an example of
"nested" records.
</p>

<p>
We end the <i>app</i> schema file by producing a "sorted" array of types: 
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">sa + moo.oschema.sort_select(hier, "app")
</pre>
</div>

<p>
Like any <i>oschema</i>, this array must include <b>all</b> of the types needed to
satisfy any type references and in an order such that any referenced
types come first.  That is, a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> must be applied to the
graph built between types and their references.  This is not so
trivial of an operation, but the <code>moo</code> Jsonnet support provides the
required algorithm.  As the <i>sys</i> schema is simple and independent from
<i>app</i> by construction we merely prepend it.
</p>

<p>
Sparing the long output here, the full schema compiled to JSON can be
produced with this command:
</p>

<pre class="example" id="orgfc9c869">
moo compile examples/oschema/app.jsonnet
</pre>

<div class="note" id="orgfc80d03">
<p>
While developing a schema, it is very useful to run <code>moo compile</code>
frequently in order to check for Jsonnet syntax or logic errors.
</p>

</div>
</div>
</div>

<div id="outline-container-schema-in-python" class="outline-3">
<h3 id="schema-in-python">Python</h3>
<div class="outline-text-3" id="text-schema-in-python">
<p>
<b>moo</b> provides support for defining <i>oschema</i> in Python which has some
similarities to its Jsonnet support.  However, Python is a far more
expressive language than Jsonnet and thus <b>moo</b> Python support provides
more options to the developer.  
</p>

<p>
Like the Jsonnet support there are layers of representation of schema
information, transformations between the layers.  These are
summarized:
</p>

<dl class="org-dl">
<dt>Object representation</dt><dd>the <code>moo.oschema</code> module provides a set of Python classes,
each associated with one <i>oschema</i> class and object instances of which
represent types.</dd>

<dt>POD representation</dt><dd>the plain-old-data representation corresponds
closely to JSON.  In fact, one may copy-paste an <i>oschema</i> type in
JSON representation into a Python file and it works as POD.  POD and
Object representations can be inter-transformed.</dd>
</dl>

<p>
Like with the Jsonnet "schema factory" object, a <code>moo.oschema.Namespace</code>
may be constructed with a <code>path</code> and then be used to construct type
objects which are "in" that path.
</p>

<p>
Python is far more expressive than Jsonnet and that leaves the
developer many choices how to work with <i>oschema</i> representations in
Python.  The example presented here make some reasonable choices that
systems may adopt but other approaches are certainly possible.  
</p>

<p>
In general we will make files which are analogous to the Jsonnet files
but which may imported as Python modules.  We take the convention that
a <code>.schema</code> module variable will hold the array of types.  These types
will be in Object form.  
</p>

<p>
Starting with the simple <i>sys</i> schema we can make something like:
</p>

<div class="org-src-container">
<pre class="src src-python">#!/usr/bin/env python3
import moo.oschema as mo
ns = mo.Namespace("sys")
schema = [ns.Number("Count", "u4")]
</pre>
</div>

<div class="note" id="org51201b3">
<p>
We name the module <code>systypes</code> to not conflict with Python's <code>sys</code> module.
</p>

</div>

<p>
The <i>app</i> schema is structured similarly, if a fair bit longer.  
</p>

<div class="org-src-container">
<pre class="src src-python">import moo.oschema as mo
import systypes

ss = {typ.name.lower(): typ for typ in systypes.schema}

ns = mo.Namespace("app")

counts = ns.sequence("Counts", ss['count'])
email = ns.string("Email", format="email",
                  doc="Electronic mail address")
affil = ns.any("Affiliation",
               doc="An associated object of any type")
mbti = ns.enum("MBTI", ["introversion", "extroversion",
                        "sensing", "intuition",
                        "thinking", "feeling",
                        "judging", "perceiving"])

make = ns.string("Make")
model = ns.string("Model")
autotype = ns.enum("VehicleClass", ["boring", "fun"])
vehicle = ns.record("Vehicle", [
    ns.field("make", make, default="Subaru"),
    ns.field("model", model, default="WRX"),
    ns.field("type", autotype, default="fun")])


person = ns.record("Person", [
    ns.field("email", email, doc="E-mail address"),
    ns.field("email2", email, doc="E-mail address", default="me@example.com"),
    ns.field("counts", counts, doc="Count of some things"),
    ns.field("counts2", counts, doc="Count of some things", default=[0, 1, 2]),
    ns.field("affil", affil, doc="Some affiliation"),
    ns.field("mbti", mbti, doc="Personality"),
    ns.field("vehicle", vehicle, doc="Example of nested record"),
    ns.field("vehicle2", vehicle, default=dict(model="CrossTrek", type="boring"),
             doc="Example of nested record with default"),
    ns.field("vehicle2", vehicle, default=dict(model="BRZ"),
             doc="Example of nested record with default"),
], doc="Describe everything there is to know about an individual human")


schema = systypes.schema + mo.depsort({k: v for k, v in globals().items() if isinstance(v, mo.BaseType)})
</pre>
</div>

<p>
Comparing this to the <code>app.jsonnet</code> above, one can see it is a near
transliteration of syntax and so we will not dwell on the details.
But, one thing to call out is that like with <code>app.jsonnet</code> we must
prepend the <i>sys</i> schema array to our result and perform a topological
sort on the types we make here.  The sort is provided by
<code>moo.oschema.depsort</code> and we play a bit of a Python trick to collect all
the <i>oschema</i> type objects made in the module using a filter on
<code>globals()</code>.
</p>
</div>

<div id="outline-container-org2d716d4" class="outline-4">
<h4 id="org2d716d4"><span class="todo TODO">TODO</span> call from moo.</h4>
<div class="outline-text-4" id="text-org2d716d4">
<ul class="org-ul">
<li>add an <code>import</code> based Python loader to <code>moo</code></li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-transforms" class="outline-2">
<h2 id="transforms">Models</h2>
<div class="outline-text-2" id="text-transforms">
<p>
The main use of <code>moo</code> is to apply a data structure ("model") to a
template in order to generate a file (eg, a C++ header file).  The
template must have an understanding ("contract") of the structure of
the model.  The "oschema" structure described here is likely not
enough information, or not in a convenient form, for templates to be
easily defined.  
</p>

<p>
We must then have means to <b>transform</b> and possibly <b>augment</b> the
initial data structure into a <b>model</b> expected by the template and
<code>moo</code> supports several strategies to supply that.
</p>
</div>

<div id="outline-container-diy-trans" class="outline-3">
<h3 id="diy-trans">DIY</h3>
<div class="outline-text-3" id="text-diy-trans">
<p>
In some cases, transformation and augmentation can may be done at the
input data structure level (ie, in Jsonnet).  <code>moo</code> "supports" this in
general by not restricting the structure of the input data.  Users are
free to come up with their own solutions.  Typically this requires
accepting a fluid contract between models and templates as one
iterates both.
</p>
</div>
</div>

<div id="outline-container-jsonnet-tla-trans" class="outline-3">
<h3 id="jsonnet-tla-trans">Jsonnet</h3>
<div class="outline-text-3" id="text-jsonnet-tla-trans">
<p>
In the case of using Jsonnet to describe the input data structure, the
<code>moo</code> CLI supports the passing "top level arguments" (TLA) to the
Jsonnet code.  This requires the Jsonnet to evaluates to a top level
function.  
</p>

<p>
This simple example shows how TLAs work:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">function(arg="", def="default") {
    arg: arg, def:def,
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">moo -A arg="hi" compile examples/oschema/tla.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    "arg": "hi",
    "def": "default"
}
</pre>
</div>

<p>
As shown, multiple TLAs may be used and default TLA values may be
given in the Jsonnet and omitted on the CLI.  A TLA may also be
specified as a Jsonnet file in which case the contents of that file
will be evaluated and the resulting structure passed to the top level
function.  Reusing the above example and the <code>sys</code> schema file:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -A arg=examples/oschema/sys.jsonnet compile examples/oschema/tla.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    "arg": [
        {
            "deps": [],
            "dtype": "u4",
            "name": "Count",
            "path": [
                "sys"
            ],
            "schema": "number"
        }
    ],
    "def": "default"
}
</pre>
</div>

<p>
Thus, with TLAs one may construct a somewhat <b>general</b> Jsonnet file that
transforms and augments some initial data structure to something more
specific.
</p>

<p>
TLAs have one more useful trick.  The function to which TLAs are given
is just a normal Jsonnet function.  This gives us the option to "bake
in" some TLAs in a Jsonnet file that calls the original function.
Consider:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local sys = import "sys.jsonnet";
local tla = import "tla.jsonnet";
tla(sys)
</pre>
</div>

<p>
Thus we may get the same output with a simpler command:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile examples/oschema/tla-sys.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    "arg": [
        {
            "deps": [],
            "dtype": "u4",
            "name": "Count",
            "path": [
                "sys"
            ],
            "schema": "number"
        }
    ],
    "def": "default"
}
</pre>
</div>

<p>
This pattern of "baking in" of TLAs can be useful, for example, if one
has a codegen system where a package must supply the specific
information but otherwise relies on a common model.  By "hiding" the
TLAs to that model in a Jsonnet file, the build system layer can be
made simpler.  See <a href="https://brettviren.github.io/moo/buildsys.html">build sys</a> document for some pointers on integrating
<code>moo</code> into popular build systems.
</p>
</div>
</div>


<div id="outline-container-python-trans" class="outline-3">
<h3 id="python-trans">Python</h3>
<div class="outline-text-3" id="text-python-trans">
<p>
Jsonnet is a "small" language (one of its charms) and some model
transformations may be complex enough that its simplicity poses a
limitation.  <code>moo</code> thus allows transformations to be defined in Python
and this opens up the ability to form the model in a more strong and
object-oriented manner.
</p>

<p>
To do this, the user may tell the <code>moo</code> CLI to apply a Python function
to transform the input data just prior to the application of the
template.  The function is specified as a "dot" path naming the
function in its module.  We may use the <code>moo dump</code> command to
illustrate a transformation applied to the <code>app</code> schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -M examples/oschema -t moo.oschema.typify dump -f pretty app.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">[&lt;Number "sys.Count"&gt;,
 &lt;Any "app.Affiliation"&gt;,
 &lt;Sequence "app.Counts" items:sys.Count&gt;,
 &lt;String "app.Email"&gt;,
 &lt;Enum "app.MBTI"&gt;,
 &lt;String "app.Make"&gt;,
 &lt;String "app.Model"&gt;,
 &lt;Enum "app.VehicleClass"&gt;,
 &lt;Record "app.Vehicle" fields:{make, model, type}&gt;,
 &lt;Record "app.Person" fields:{email, email2, counts, counts2, affil, mbti, vehicle, vehicle2, vehicle2}&gt;]
</pre>
</div>

<p>
The built-in <code>moo.oschema.typify()</code> function illustrated here converts a
schema type as a "raw" data structure into a corresponding Python
object.  In a template, the Python object should be usable everywhere
the "raw" data structure.  The <code>typify()</code> transform is thus only useful
if the extensions that the Python object provides are needed in a
template or if subsequent transforms require objects instead of raw
data structures (an example of which we'll see next).
</p>

<p>
We may also pipeline transformations.  Here is an example that will
use the output of <code>typify()</code>, form a graph from the type reference
dependencies, and perform a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> to produce an array which
are ordered from least dependent to most.  
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -T examples/oschema -M examples/oschema \
    -t 'moo.oschema.typify|moo.oschema.graph|moo.oschema.depsort' \
      render app.jsonnet ool.txt.j2
</pre>
</div>

<pre class="example" id="orged643bc">
Iterate over list of types:
&lt;Number "sys.Count"&gt;
&lt;Any "app.Affiliation"&gt;
&lt;Sequence "app.Counts" items:sys.Count&gt;
&lt;String "app.Email"&gt;
&lt;Enum "app.MBTI"&gt;
&lt;String "app.Make"&gt;
&lt;String "app.Model"&gt;
&lt;Enum "app.VehicleClass"&gt;
&lt;Record "app.Vehicle" fields:{make, model, type}&gt;
&lt;Record "app.Person" fields:{email, email2, counts, counts2, affil, mbti, vehicle, vehicle2, vehicle2}&gt;
</pre>

<p>
Note the <code>Person</code> type comes after the types that it refers to in its
fields due to the topological sort.  Also, note that this particular
transform may also be performed in the Jsonnet layer and so is used
here as an illustration of the functionality.
</p>

<p>
This example also shows that the pipeline of transformations may
becomes rather complex.  At some point, developing a composite
transformation function in Python and referring to it on the <code>moo</code> CLI
may be useful to keep the command argument list small.  
</p>

<p>
But, let us now move on to codegen.
</p>
</div>
</div>
</div>


<div id="outline-container-codegen" class="outline-2">
<h2 id="codegen">Codegen</h2>
<div class="outline-text-2" id="text-codegen">
<p>
Some trivial templates were introduced above in order to dump out some
of the information in their models.  Here we develop two "real"
templates and apply them to the <code>app</code> schema to generate code.
</p>

<dl class="org-dl">
<dt><code>ostructs.hpp.j2</code></dt><dd>generate a C++ header a defining a C++ <code>namespace</code>
scope and holding definition of a C++ <code>struct</code> type for each type
instance of the schema class <code>record</code> with a <code>path</code> in that scope.</dd>

<dt><code>onljs.hpp.j2</code></dt><dd>for each C++ <code>struct</code> defined above, produce functions
that will allow the <code>struct</code> to participate in <code>nlohmann::json</code> (nljs)
based serialization.</dd>
</dl>

<p>
But, before developing the templates we first define a contract or
<b>model</b> on which the template development may depend.
</p>
</div>

<div id="outline-container-model" class="outline-3">
<h3 id="model">Model</h3>
<div class="outline-text-3" id="text-model">
<p>
The <code>omodel</code> contract is embodied in this Jsonnet file:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">local oschema = import "oschema.jsonnet";

function(os, path, ctxpath=[]) {

    // The "path" determines which schema types in the "os" array will
    // be considered to be directly "in" the model.  The "path" may be
    // give either as a literal list of string or encoded as a
    // dot-separated string.  It is used, eg, to form a surrounding
    // C++ namespace containing the codegen'ed types.
    path: oschema.listify(path),

    // The "context path" is a prefix of the "path" to be removed when
    // refering to this model from external resources and in a
    // relative way.  Eg, the ctxpath is removed from the path when
    // forming relative #include statements between "sibling" headers
    // generated from this model.  It may either be a litteral list of
    // strings or a list of string encoded as a dot-separated string.
    ctxpath: oschema.listify(ctxpath),

    // Select out the types which are "in" the path for consideration.
    types: [t for t in os if oschema.isin(self.path, t.path)],

    // Also provide the super set of all types so that referenced
    // types may be resolved.  This super set should be complete to
    // any type referenced by a type in the "types" array above.
    all_types: os,

    // Reference any type by its FQN.
    byref: {[oschema.fqn(t)]:t for t in $.all_types},

    // Collect the types of interest by their schema class name
    byscn: {[tn]:[oschema.fqn(t) for t in $.types if t.schema == tn]
                   for tn in oschema.class_names},

    // Find external type references
    local extypref = [
        d for d in std.flattenArrays([t.deps for t in $.types])
          if !oschema.isin($.path,oschema.listify(d))],
    extrefs: std.uniq(std.sort([oschema.relpath(oschema.basepath(t), self.ctxpath) for t in extypref]))
}
</pre>
</div>

<p>
The top-level arguments are described below.  What is produced is an
object (ie, an instance of the model) with these attributes:
</p>

<dl class="org-dl">
<dt><code>path</code></dt><dd>the <code>namespace</code> path scope to focus on as a list/array</dd>
<dt><code>nspre</code></dt><dd><code>namespace</code> prefix with trailing dot</dd>
<dt><code>types</code></dt><dd>array of type data structures which are in scope</dd>
<dt><code>byref</code></dt><dd>full type information retrieved via a type reference</dd>
<dt><code>byscn</code></dt><dd>references to types collected by schema class</dd>
<dt><code>extref</code></dt><dd>list of references to types outside the scope</dd>
</dl>

<p>
Top-level arguments
</p>

<dl class="org-dl">
<dt><code>os</code></dt><dd>bring in the <code>oschema</code> array</dd>
<dt><code>path</code></dt><dd>the <code>namespace</code> path with which select a branch on the full schema tree</dd>
</dl>

<p>
We can test out some TLAs and test that the model compiles using the <code>moo</code> CLI:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -M examples/oschema \
  -A os='app.jsonnet' -A path='app' \
     compile omodel.jsonnet
</pre>
</div>

<p>
We want to apply a transform to the <code>types</code> attribute and can test that
with.  This can be done by with this command.  We will hold off on
showing the output until the next example CLI.
</p>


<div class="org-src-container">
<pre class="src src-shell">moo -M examples/oschema \
  -A os='app.jsonnet' -A path='app' \
  -t '/types:moo.oschema.typify|moo.oschema.graph|moo.oschema.depsort' \
     dump -f pretty omodel.jsonnet
</pre>
</div>

<p>
We are almost ready to turn to the template but one last detail is
needed.  As we will find there are some utilities that will simplify
developing the template and which are specific to the target-language
(eg C++) and which the rest of the model does not depend.  We will
bring these in as a model "graft".
</p>


<div class="org-src-container">
<pre class="src src-shell">moo -g '/lang:ocpp.jsonnet' \
    -M examples/oschema \
    -A os='app.jsonnet' -A path='app' \
    -t '/types:moo.oschema.typify|moo.oschema.graph|moo.oschema.depsort' \
    dump -f types omodel.jsonnet
</pre>
</div>

<pre class="example" id="org9860845">
all_types &lt;class 'list'&gt;
byref &lt;class 'dict'&gt;
byscn &lt;class 'dict'&gt;
ctxpath &lt;class 'list'&gt;
extrefs &lt;class 'list'&gt;
path &lt;class 'list'&gt;
types &lt;class 'list'&gt;
lang &lt;class 'dict'&gt;
</pre>

<p>
If you squint you'll see the <code>lang</code> attribute added with others from the
model.  Let's now move to the template.
</p>
</div>
</div>



<div id="outline-container-struct" class="outline-3">
<h3 id="struct">Template</h3>
<div class="outline-text-3" id="text-struct">
<p>
The <a href="moo/templates/ostructs.hpp.j2">ostructs.hpp.j2</a> template file gets applied to the <code>omodel</code> to
produce a C++ header file defining a <code>struct</code> for each <code>record</code> instance
in the model and any supporting types via a <code>using</code> type alias.  It also
uses the <code>extref</code> info to <code>#include</code> any required external headers that
themselves are also generated from other parts of the overall schema.
</p>

<p>
Take particular note that this <code>#include</code> pattern <b>bakes in a specific
mapping</b> from a type's <code>path</code> array to file locations.  For the resulting
C++ code to compile, this pattern must of course actually be honored
in some way.  This may be done manually by properly placing the
generated files according to this mapping or, better, be automatically
assured via a build system.  Future work may generate this file-system
level assurance itself from schema.  For now, we must simply be careful.
</p>

<p>
Finally, note that the grafting of <code>ocpp.jsonnet</code> selects a particular
mapping from schema class names to their C++ equivalents.  Eg,
<code>nlohman::json</code> for <code>any</code>.  If we wished to generate code using a
different mapping, such as <code>boost::any</code> for <code>any</code> we would need to modify
or fork this grafted data structure while the rest of the structure
may be left as-is.
</p>

<p>
We can finally generate code by changing the above CLI call from <code>dump</code>
to <code>render</code> and adding the template file name.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -g '/lang:ocpp.jsonnet' \
    -M examples/oschema \
    -A os='app.jsonnet' -A path='app' \
    render omodel.jsonnet ostructs.hpp.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">/*
 * This file is 100% generated.  Any manual edits will likely be lost.
 *
 * This contains struct and other type definitions for shema in 
 * namespace app.
 */
#ifndef APP_STRUCTS_HPP
#define APP_STRUCTS_HPP

#include &lt;cstdint&gt;
#include "sys/Structs.hpp"

#include &lt;nlohmann/json.hpp&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

namespace app {

    // @brief An associated object of any type
    using Affiliation = nlohmann::json;

    // @brief All the counts
    using Counts = std::vector&lt;sys::Count&gt;;

    // @brief Electronic mail address
    using Email = std::string;

    // @brief 
    enum class MBTI: unsigned {
        introversion,
        extroversion,
        sensing,
        intuition,
        thinking,
        feeling,
        judging,
        perceiving,
    };
    // return a string representation of a MBTI.
    inline
    const char* str(MBTI val) {
        if (val == MBTI::introversion) { return "introversion" ;}
        if (val == MBTI::extroversion) { return "extroversion" ;}
        if (val == MBTI::sensing) { return "sensing" ;}
        if (val == MBTI::intuition) { return "intuition" ;}
        if (val == MBTI::thinking) { return "thinking" ;}
        if (val == MBTI::feeling) { return "feeling" ;}
        if (val == MBTI::judging) { return "judging" ;}
        if (val == MBTI::perceiving) { return "perceiving" ;}
        return "";                  // should not reach
    }
    inline
    MBTI parse_MBTI(std::string val, MBTI def = MBTI::introversion) {
        if (val == "introversion") { return MBTI::introversion; }
        if (val == "extroversion") { return MBTI::extroversion; }
        if (val == "sensing") { return MBTI::sensing; }
        if (val == "intuition") { return MBTI::intuition; }
        if (val == "thinking") { return MBTI::thinking; }
        if (val == "feeling") { return MBTI::feeling; }
        if (val == "judging") { return MBTI::judging; }
        if (val == "perceiving") { return MBTI::perceiving; }
        return def;
    }

    // @brief 
    using Make = std::string;

    // @brief 
    using Model = std::string;

    // @brief 
    enum class VehicleClass: unsigned {
        boring,
        fun,
    };
    // return a string representation of a VehicleClass.
    inline
    const char* str(VehicleClass val) {
        if (val == VehicleClass::boring) { return "boring" ;}
        if (val == VehicleClass::fun) { return "fun" ;}
        return "";                  // should not reach
    }
    inline
    VehicleClass parse_VehicleClass(std::string val, VehicleClass def = VehicleClass::boring) {
        if (val == "boring") { return VehicleClass::boring; }
        if (val == "fun") { return VehicleClass::fun; }
        return def;
    }

    // @brief 
    struct Vehicle {

        // @brief 
        Make make = "Subaru";

        // @brief 
        Model model = "WRX";

        // @brief 
        VehicleClass type = app::VehicleClass::fun;
    };

    // @brief Describe everything there is to know about an individual human
    struct Person {

        // @brief E-mail address
        Email email = "";

        // @brief E-mail address
        Email email2 = "me@example.com";

        // @brief Count of some things
        Counts counts = {};

        // @brief Count of some things
        Counts counts2 = {0, 1, 2};

        // @brief Some affiliation
        Affiliation affil = {};

        // @brief Personality
        MBTI mbti = app::MBTI::introversion;

        // @brief Example of nested record
        Vehicle vehicle = {"Subaru", "WRX", app::VehicleClass::fun};

        // @brief Example of nested record with default
        Vehicle vehicle2 = {"Subaru", "CrossTrek", app::VehicleClass::boring};

        // @brief Example of nested record with default
        Vehicle vehicle2 = {"Subaru", "BRZ", app::VehicleClass::fun};
    };

} // namespace app

#endif // APP_STRUCTS_HPP
</pre>
</div>

<p>
And, here are the corresponding <code>nlohmann::json</code> serialization
functions, produced by applying the <a href="moo/templates/oschema/onljs.hpp.j2">onljs.hpp.j2</a> template to the same
model.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo -g '/lang:ocpp.jsonnet' \
    -M examples/oschema \
    -A os='app.jsonnet' -A path='app' \
    render omodel.jsonnet onljs.hpp.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++">/*
 * This file is 100% generated.  Any manual edits will likely be lost.
 *
 * This contains functions struct and other type definitions for shema in 
 * namespace app to be serialized via nlohmann::json.
 */
#ifndef APP_NLJS_HPP
#define APP_NLJS_HPP

// My structs
#include "app/Structs.hpp"

// Nljs for externally referenced schema
#include "sys/Nljs.hpp"

#include &lt;nlohmann/json.hpp&gt;

namespace app {

    using data_t = nlohmann::json;    NLOHMANN_JSON_SERIALIZE_ENUM( MBTI, {
            { app::MBTI::introversion, "introversion" },
            { app::MBTI::extroversion, "extroversion" },
            { app::MBTI::sensing, "sensing" },
            { app::MBTI::intuition, "intuition" },
            { app::MBTI::thinking, "thinking" },
            { app::MBTI::feeling, "feeling" },
            { app::MBTI::judging, "judging" },
            { app::MBTI::perceiving, "perceiving" },
        })
    NLOHMANN_JSON_SERIALIZE_ENUM( VehicleClass, {
            { app::VehicleClass::boring, "boring" },
            { app::VehicleClass::fun, "fun" },
        })


    inline void to_json(data_t&amp; j, const Vehicle&amp; obj) {
        j["make"] = obj.make;
        j["model"] = obj.model;
        j["type"] = obj.type;
    }

    inline void from_json(const data_t&amp; j, Vehicle&amp; obj) {
        if (j.contains("make"))
            j.at("make").get_to(obj.make);    
        if (j.contains("model"))
            j.at("model").get_to(obj.model);    
        if (j.contains("type"))
            j.at("type").get_to(obj.type);    
    }

    inline void to_json(data_t&amp; j, const Person&amp; obj) {
        j["email"] = obj.email;
        j["email2"] = obj.email2;
        j["counts"] = obj.counts;
        j["counts2"] = obj.counts2;
        j["affil"] = obj.affil;
        j["mbti"] = obj.mbti;
        j["vehicle"] = obj.vehicle;
        j["vehicle2"] = obj.vehicle2;
        j["vehicle2"] = obj.vehicle2;
    }

    inline void from_json(const data_t&amp; j, Person&amp; obj) {
        if (j.contains("email"))
            j.at("email").get_to(obj.email);    
        if (j.contains("email2"))
            j.at("email2").get_to(obj.email2);    
        if (j.contains("counts"))
            j.at("counts").get_to(obj.counts);    
        if (j.contains("counts2"))
            j.at("counts2").get_to(obj.counts2);    
        obj.affil = j.at("affil");
        if (j.contains("mbti"))
            j.at("mbti").get_to(obj.mbti);    
        if (j.contains("vehicle"))
            j.at("vehicle").get_to(obj.vehicle);    
        if (j.contains("vehicle2"))
            j.at("vehicle2").get_to(obj.vehicle2);    
        if (j.contains("vehicle2"))
            j.at("vehicle2").get_to(obj.vehicle2);    
    }

} // namespace app

#endif // APP_NLJS_HPP
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-objects" class="outline-2">
<h2 id="objects">Objects</h2>
<div class="outline-text-2" id="text-objects">
<p>
Besides generating code from a schema, data objects may be constructed
with the help of and validated against schema.  For information about
this usage pattern see the <a href="otypes.html">otypes document</a> which describes how to use
the <code>moo.otypes</code> module.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Viren</p>
<p class="date">Created: 2021-01-19 Tue 13:45</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
