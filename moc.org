#+title: moc
#+subtitle: Model Oriented Configuration
#+setupfile: setup.org
#+options: broken-links:mark


* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:


moc is a moo for a /configuration/ system.  It provides::

- a vocabulary for defining the /schema/ that configuration information should follow.

- tooling to validate configuration objects against their schema.

- code generators creating native language (C++/Python) types and serialization methods between those types and configuration objects.

- native language libraries and shell programs for producing and consuming configuration in a variety of /formats/ and media including files and /streams/.

- a demo application and configuration.

* Dive in
  :PROPERTIES:
  :CUSTOM_ID: dive-in
  :END:

moc is currently not production but rather provides a mock up demo.
To use it, first install the ~moo~ Python package eg like:

#+begin_example
  $ echo layout python3 > .envrc
  $ direnv allow
#+end_example

Or, if you don't have ~direnv~

#+begin_example
  $ python3 -m venv venv
  $ source venv/bin/activiate
#+end_example

Then install ~moo~

#+begin_example
  $ pip install -e .
  $ moo --help
#+end_example

The moc demo is in [[file:moc/][moc/]]:

#+begin_example
  $ cd moc
  $ make
#+end_example


* Technical design
  :PROPERTIES:
  :CUSTOM_ID: technical-design
  :END:

moc is a *moo* focused on generating configuration objects and various means to deliver them into an application.  This section describes aspects of the technical design.

** Streams, frames and messages
   :PROPERTIES:
   :CUSTOM_ID: stream-frame-message
   :END:

moc configuration data follows an abstract low level format which may be realized in a few ways and independently from the concrete high level schema of the delivered content.  This provides flexibility to an application to select how configuration information is delivered  

The abstract low level format is defined in terms of *streams* of *bytes*, *frames* and *messages* as described:

- bytes :: A *moc byte stream* consists of a sequence of 8 bit bytes.  Several types of byte streams are supported by moc including commonly known ones (eg, a JSON object or a [[https://en.wikipedia.org/wiki/JSON_streaming][JSON stream]] and ones suitable for message passing systems like ZeroMQ).  Some byte streams may place limits the format of information they carry (eg, a JSON Stream may be used only for JSON text).

- frames :: A *moc frame stream* consists of a logical sequence of frames derived from a bytes stream.  A frame is a contiguous and finite sequence of bytes which may be read into memory in an atomic manner.  If two byte streams support the format of a frame then they both shall decode an identical frame identically.  

- messages :: A *moc message stream* consists of a logical sequence of messages derived from a frame stream.  The application may determine the extent and interpretation of the message by progressively examining the frames.  moc messages must have an initial frame, called the message type *hint* which must consist of only printable ASCII characters suitable for use in forming a C symbol.  moc reserves a number of hint values, listed in the table below which are to be used to identify the low-level format of the next and last frame in the message called the *payload*.  The application is free to extend the list of message type hints it supports.

- types :: A *moc type stream* produces a stream of objects in native language type.  It serializes messages from a moc message stream.  When used, the application must know the type expected.

** Reserved message types
   :PROPERTIES:
   :CUSTOM_ID: message-types
   :END:

The set of reserved moc message type hints are:

|------+------------------+-----+--------|
| hint | payload encoding | C++ | Python |
|------+------------------+-----+--------|
| JSON | JSON string      | yes |        |
| BSON | Binary JSON      | yes |        |
| CBOR | Binary JSON      | yes |        |
| UBJS | Binary JSON      | yes |        |
| MSGP | Message Pack     | yes |        |
| JSNT | Jsonnet string   |     |        |
| AVRJ | Avro JSON        |     |        |
| AVRB | Avro binary      |     |        |
| PBUF | Protobuf         |     |        |
|------+------------------+-----+--------|

** Byte stream formats
   :PROPERTIES:
   :CUSTOM_ID: byte-stream-formats
   :END:


moc provides byte stream decoding for a few common types:

- JSON :: the bytes stream is assumed to be a [[https://en.wikipedia.org/wiki/JSON_streaming][JSON stream]].  As it may only hold JSON format data the moc message type hint is implicitly and always ~JSON~.  The stream may consist of an admixed concatenation of JSON types.  The first frame from a JSON byte stream is the string ~JSON~ which is implicitly generated.  The second frame will contain the JSON text of the first JSON type in the stream.  This then repeats until the stream is exhausted.

- SHFM :: a "size-hinted framed message" may hold arbitrary data (binary and text, including JSON) and is well suited for use with ZeroMQ or other message passing systems.  In the byte stream, a frame is prefixed with a binary value holding the size of the frame data measured in bytes.  If less than 255 the size value is stored in a single byte.  If the size is 255 or greater but less than 2^32-1 the first byte is 255 (~0xff~) and the next four bytes hold the size as a 32 bit integer.  The first frame in a message shall provide the message type hint and for hints reserved by moc, the subsequent and only other frame in the message holds the payload frame of that type.  An example SHFM message is shown next with a frame depicted as ~[size|body]~ where the ~size~ in a binary value and the ~body~ is expressed in ASCII:

#+begin_example
[4|JSON][8|{"a":42}]
#+end_example

** Schema
   :PROPERTIES:
   :CUSTOM_ID: schema
   :END:


The producer and consumer of a moc *message stream* must honor a shared *contract* (or *schema*) which governs the structure of the data.  A particular schema may span one of these possible levels of context:

- payload :: the structure of a given payload frame body.  
- intra message :: the structure of payload frames in a message.  
- inter message :: the structure of messages in a stream

moc provides a means to rigorously define schema as a (meta) data structure and with two goals in mind for the use of a schema:

- validation :: a schema may be used to check if a given data object (aka *model*) obeys the contract defined by the schema.
- generation :: a schema object may be applied to a *template* in order to generate a *representation*.

These two goals require different data structure.  For example, a validation schema is well represented as a data structure which itself obeys the JSON Schema while a generation schema is better represented by a data structure which itself obeys the Avro Schema.  

To avoid developing two conceptually identical schema structures to satisfy these two forms, moc provides support for a developer to define a schema abstractly in the form of Jsonnet function calls.  These functions are parameterized on a Jsonnet object holding primitive schema defining functions.  This allows the same developer-provided functions to be called with JSON Schema primitives or with Avro Schema primitives and output the proper structure for each.

** Example schema
   :PROPERTIES:
   :CUSTOM_ID: example-schema
   :END:


A simple example makes this clear.  As described above, moc reserves a set of message type hints.  We may define schema for this simple frame like:

#+include: moc/simple.jsonnet src jsonnet

With the above, ~moo~ can validate that ~data~ is correct against ~jscm~:

#+begin_src shell :exports both :results output code :wrap "example"
moo validate -s moc/simple.jsonnet -S jscm -D data moc/simple.jsonnet
#+end_src

#+RESULTS:
#+begin_example
null
#+end_example

The null means no error.

We may use ~moo~ to compile the ~avro~ structure to an Avro schema JSON file and generate code:

#+begin_src shell :exports both :results output code :wrap "src c++"
moo compile -P avro moc/simple.jsonnet > simple.json
avrogencpp -n moc -i simple.json -o simple_avro.hpp
grep -m1 -A10 Hint: simple_avro.hpp
#+end_src

#+RESULTS:
#+begin_src c++
enum class Hint: unsigned {
    JSON,
    BSON,
    CBOR,
    UBJS,
    MSGP,
    JSNT,
    AVRJ,
    AVRB,
    PBUF,
};
#+end_src

In that header is more generated code to serialize this ~enum~ via the Avro codec.  moc may provide methods to transparently select that codec based on the "hint" being ~AVRJ~ or ~AVRB~.

moc also supports ~nlohmann::json~ family of codecs to support the remaining hints besides ~PBUF~.  With a suitable template file and the info supplied in the model by the ~tmpl~ attribute, ~moo~ can generate the needed code like:

#+begin_src shell :exports both :results output code :wrap "src c++"
moo render -P tmpl moc/simple.jsonnet moc/avro_nljs.hpp.j2 > simple_nljs.hpp
grep -m1 -A10 ENUM simple_nljs.hpp
#+end_src

#+RESULTS:
#+begin_src c++
    NLOHMANN_JSON_SERIALIZE_ENUM( Hint, {
            { moc::Hint::JSON, "JSON" },
            { moc::Hint::BSON, "BSON" },
            { moc::Hint::CBOR, "CBOR" },
            { moc::Hint::UBJS, "UBJS" },
            { moc::Hint::MSGP, "MSGP" },
            { moc::Hint::JSNT, "JSNT" },
            { moc::Hint::AVRJ, "AVRJ" },
            { moc::Hint::AVRB, "AVRB" },
            { moc::Hint::PBUF, "PBUF" },
        })
#+end_src

Where this snippet shows how we ultimately rely on a CPP macro provided by ~nlohmann~ to generate codec.  This produces ~to_json()~ and ~from_json()~ type functions.

** Payload schema
   :PROPERTIES:
   :CUSTOM_ID: payload-schema
   :END:


The simple example above may be considered also an example of a trivial payload body schema.  However, a payload schema will typically be rather more complex.  It will be built from various primitive schema types as well as built up further upon types it defines itself.  For example, consider a schema describing the simple object example from [[https://github.com/nlohmann/json/#arbitrary-types-conversions][nlohmann::json]] documentation:

#+include: moc/person.jsonnet src jsonnet

The fundamental types provided by moo are an amalgamation of those named by Avro and JSON Schema: ~boolean~, ~string~, ~number~, ~array~ of a type and ~record~ aggregating a number of ~field~ elements, each of a type.  

** Intra-message Schema
   :PROPERTIES:
   :CUSTOM_ID: intra-message
   :END:


The message type hints reserved by moc also specify exactly one message payload frame may follow.  The intra-message schema for these types is thus specified.

Application developers are free to extend the supported hints to include message types with multiple payload frames.  They may develop schema to describe the message as a hole in terms of an array of schema.  

For example, an application may prefer define a "PEOPLE" message type which puts in each frame a ~person~ record as described in the example above.  An intra-message schema may then be defined as the ~people~ schema.  What is required in the Jsonnet is to expose more of the internal schema structure for example as:

#+begin_src jsonnet
  // as above
  {
      schema(s):: {
          // [...as above omitted...]
          // person
          people: s.array(self.person),
      }
      jscm: self.schema(j.schema).people,
      avro: self.schema(a.schema).people,
  }
#+end_src

Note we comment out the "return value" ~person~ and instead use its local definition as a type to define the returned ~people~.

The same document may produce JSON Schema and Avro schema for all abstract schema:

#+begin_src jsonnet
  {
      schema(s) :: {
          // locals as above but return object of:
          person: person,
          people: people,
      }
      jscm: self.schema(j.schema),
      avro: self.schema(a.schema),
  }
#+end_src

When applying either of the produced schema one has to take into account the substructure.  Eg, ~avro.person~ would be used to generate a ~Person~ object.

** Inter-message schema
   :PROPERTIES:
   :CUSTOM_ID: inter-message
   :END:

Inter-message schema may be (under) specified simply as an array of expected hints.   Or the same patterns described above may be extended to cover multiple messages as they are shown to cover multiple frames.  In other words, it may be schema all the way down.  

* Package layout


* Extensions

- new hints to allow different payload format or 0 or more than one payload frames
- intra-message schema when multiple payloads are allowed.  this can likely mimic inter-message schema


* Blah blah


The working demonstration is a distributed system which decomposes into 

- a single, general software /application/ (something with a ~main()~) which aggregates

- a set of software /components/ that are provided in

- dynamically loaded plugin shared libraries resulting in a number of

- running /process/ instances 

The application is general and has these explicit parts:

- command line parsing 
- load any plugins named on the CLI
- instantiate a moc entry point component based on CLI arguments
- execute moc entry point to receive application configuration
- load additional plugins as per cfg
- instantiate components as per cfg
- apply component cfg on instances
- execute instances

This demo is a one-shot configuration, there is no re-config mechanism.  This may be developed as an extension.

moc configuration information may exist in serialized /message/ form and in a native language (C++/python) fully typed class.  The code providing /deserializing/ methods is generated based on a moo schema defining the configuration structure.  Generated code is compiled into headers and source which the application and components may be developed against.






* mock up

Want:

- define rules for validating structure expressed in JSON
- map a structure composed values in JSON types to C++/Python class definitions
- generate code to serialize values to C++/Python instances
- allow for partial serializing in order to delegate serializing.

Want to construct a node, eg inside ~main()~ or maybe inside some main ~Application~ object:

#+begin_src c++
  // This mock up will create and configure an instance of "Node" which
  // whill create, configure and aggregate instances of "Port" and
  // "Comp" (component) each of which uses some subset of the ports.

  // The process is driven by a particular configuration istream.  The
  // program may have different types of config streams and which used
  // is determined by a meta configuration such as provided on the
  // command line.  The CfgStreamKey categorizes the type and any
  // additional information needed to instantiate or access a config
  // stream.
  CfgStreamKey cfg_stream_info = parse_cli_arg_for_cfg_stream_info();

  // Resolve the key a CfgStream object.  A CfgStream provides a
  // sequence interface.  Maybe like std::istream, std::queue, or ZeroMQ
  // socket.
  CfgStream& cfgstream = get_cfgstream(cfg_stream_info); 

  std::vector<Node> nodes;
  while (!cfgstream.empty()) {
      nodes.emplace_back(cfgstream);
  }
#+end_src

Inside the ~Node~ constructor we process the configuration stream to make ports and node components.

#+begin_src c++
  // We assume the stream follows a protocol.  The stream is to consist
  // of distinct frames and frames are grouped into messages.  A frame
  // is read into application memory in an atomic manner.  The number of
  // frames in a message the the interpretation of each frame may depend
  // on previous frames in the message.

  // We assume a message has an initial frame consisting of a string
  // which gives the format to assume for the second frame.  Eg,
  // ["JSON",<JSON text>].  We hide this interpretation and return a C++
  // class that the Node constructor code knows.  More on this constructor
  // later.
  NodeCfg nodecfg(cfgstream);

  cout << "Loading node ID: " << nodecfg.ident() << "\n";

  // A node instantiates, configures and aggregates ports.  Here, a port
  // is assumed to be some socket with a "smart" constuction driven by
  // the configuration.  Eg, it may perform auto discovery of peers.
  // But, in this mock up it also represents any type of shared objects
  // or resources that need to be constructed outside the components.
  // Note: in this mockup, configuration supersedes ports.  We may want
  // to have configuratoin delivered via a port in which case these
  // patterns need to be largely refactored.  One way would be to allow
  // a component to be a node.  Then use a top node constructed a local
  // cfgstream to construct a component node that listens on a port to
  // produce a configuration stream that generates one or more new nodes.
  std::vector<Port> ports;
  for (PortCfg portcfg: nodecfg.portdefs()) {
      ports.emplace_back(portcfg);
  }
  go_online(ports);

  // We may need to use ports outside the constructor and at least
  // should keep them alive.
  m_ports = ports;

  // The Node constructor only cares about configuring any components
  // and does so through a factory method which returns a component as
  // an abtrace IConfigurable facet.  We assume the factory holds on to
  // the instance.
  for (CompCfg compcfg : nodecfg.compdefs()) {
      // Get type name and instance identifier
      auto tn = compcfg.type_name();
      auto id = compcfg.ident();
      auto& comp = factory.get<IComponent>(tn, id);
      // Some components need ports, but the node creates them so the
      // component says which ones they want by name (ident).
      auto ports = get_ports(compcfg.ports());
      comp->configure(id, cfgstream, ports);
  }

  // This mockup is about configuration patterns so it omits other
  // possible Node-level configuration items.  As a placeholder we imply
  // that by saving the NodeCfg for use in other Node methods.
  m_cfg = nodecfg;

  // But, suggest one possible additional configuration processing: Not
  // all components are necessarily configurable and thus the node is
  // given a possible superset which lists all components that are
  // runable.
  for (auto torun : compcfg.runnables()) {
      m_runables.push_back(factor.get<IRunnable>(torun));
  }
  // later in a Node::run() we may forward the call to components.
#+end_src


We create

- a configuration object (cfgobj) in JSON 
- a validation object (valobj) in JSON Schema vocabulary to validate a cfgobj
- a definition structure (defobj) in Avro Schema to produce C++ or Python types

Processing

- a defobj is created as JSON
- Avro generate is run to produce C++ or Python
- a cfgobj is created as JSON
-  

* Configuration store

We want:

- to construct an application out of components dynamically driven by configuration information. 
- Provide configuration in a way that can be progressively consumed and applied 
- Allow for multiple sources of config, including files and messages.
- Provide serialization to native types.
- Do not tightly couple configuration and interpretation

The stream introduced above breaks that last one.  Eg configuration
frames in the stream must be ordered to match how the code tries to
apply.  In the example, depth-first ordering is required.  This is
however a natural order for eg JSON.


 
