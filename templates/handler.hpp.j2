{% import 'ctxsml_macros.j2' as moo %}
#ifndef {{namespace|upper}}_{{protoname|upper}}_HANDLER_HPP_SEEN
#define {{namespace|upper}}_{{protoname|upper}}_HANDLER_HPP_SEEN

namespace {{namespace}} {

    namespace {{protoname}} {
        // States
        {% for st in machine.states %}
        {{ moo.struct(st)|indent}}
        {% endfor %}

        // Events
        {% for eve in machine.events %}
        {{ moo.struct(eve)|indent}}
        {% endfor %}

        struct Context {

            virtual ~Context() {}

            // event guards
            {% for eg in machine.event_guards %}
            {{ moo.event_method_decl_purevirt(eg[0], eg[1], namespace + "::" + protoname)|indent }}
            {% endfor %}

            // actions
            {% for ea in machine.event_actions %}
            {{ moo.event_method_decl_purevirt(ea[0], ea[1], namespace + "::" + protoname)|indent }}
            {% endfor %}
      
        };

        struct FSM {

            auto operator()() {
                using namespace boost::sml;
                using namespace {{namespace}}::{{protoname}};

                // clang-format off
                return make_transition_table(
{{ moo.smltt_lambdas(machine.tt) }}
                    );
                // clang-format on
            }
        };

        // Construct like:
        //     MyContext ctx(myapp, proto_codec);
        //     sml::sm<{{protoname}}::FSM> sm{ctx}
        // Assuming MyContext inherits from {{protoname}}::Context

    } // namespace {{protoname}}

} // namespace {{namespace}}

#endif // {{namespace|upper}}_{{protoname|upper}}_HANDLER_HPP_SEEN
