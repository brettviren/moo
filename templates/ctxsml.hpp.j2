{% import 'ctxsml_macros.j2' as moo %}
#ifndef {{namespace|upper}}_{{structname|upper}}_HPP_SEEN
#define {{namespace|upper}}_{{structname|upper}}_HPP_SEEN

#include "{{namespace|lower}}/messages.hpp"
#include "{{namespace|lower}}/states.hpp"

#include <string>
#include <sml.hpp>
#include <cassert>

namespace {{namespace}} {

    struct {{structname}} {

        // event guards
        {% for eg in event_guards %}
        {{ moo.event_method_decl(eg[0], eg[1], namespace)|indent }}
        {% endfor %}

        // actions
        {% for ea in event_actions %}
        {{ moo.event_method_decl(ea[0], ea[1], namespace)|indent }}
        {% endfor %}

        // context

        {{ moo.struct(context)|indent }}
        {{context.name}} ctx;

        auto operator()() {
            using namespace boost::sml;

            // clang-format off
            return make_transition_table(
{{ moo.smltt_lambdas(machine.tt, namespace) }}
                );
            // clang-format on
        }

    };

    inline
    void test_{{structname}}() {
        namespace sml = boost::sml;
        sml::sm<{{structname}}> fsm{ {{structname}} {}};
        {% for et in test_fsm_events %}
        fsm.process_event({{namespace}}::{{et[0]}} {});
        assert(fsm.is(sml::state<{{namespace}}::{{et[1]}}>));
        {% endfor %}
    }

}

#endif // {{namespace|upper}}_{{classname|upper}}_HPP_SEEN
