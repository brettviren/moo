{%- macro struct(obj) %}
struct {{ obj.name }} {
    {% for a in obj.attrs %}
    {% if a.type.name == "str" %}
        {{a.type.c}} {{a.name}} = "{{a.def}}";
    {% else %}
        {{a.type.c}} {{a.name}} = {{a.def}};
    {% endif %}
    {% endfor %}
    };
{%- endmacro %}
{%- macro event_method_decl(e,m) %}
{{m.type.c}} {{m.name}}(const {{e.name}}& event{% for a in m.attrs %}, {{a.type.c}} {{a.name}}{% endfor %});
{%- endmacro %}
{%- macro sml_lambda_guard(grds) %}
{%- if grds|length > 0 -%}[{%- for g in grds -%}
    {{ ' and ' if not loop.first }} [this](const auto& event){ return this->{{g.name}}(event); }
    {%- endfor -%}]{%- endif -%}
{%- endmacro %}
{%- macro sml_lambda_action(acts) %}
{%- if acts|length > 0 -%}({%- for a in acts -%}
    {{ ', ' if not loop.first }} [this](const auto& event){ this->{{a.name}}(event); }
    {%- endfor %} ){%- endif -%}
{%- endmacro %}
{%- macro sml_lambda_ega(t) %}
{%- if t.event -%}
+ event<{{t.event.name}}>
{%- endif -%}
{%- if t.guards or t.actions %}
{{ sml_lambda_guard(t.guards) }} / {{ sml_lambda_action(t.actions) }}
{%- endif -%}
{%- endmacro %}
{%- macro sml_lambda_tran(t) %}
{{t.star if t.star}} state<{{t.ini.name}}> {{sml_lambda_ega(t)}} = state<{{ t.fin.name }}>
{%- endmacro %}
{%- macro smltt_lambdas(tt) %}
{% for t in tt -%}
{{ "," if not loop.first }}{{ sml_lambda_tran(t) }}
{% endfor %}
{%- endmacro %}
#ifndef {{namespace|upper}}_{{structname|upper}}_HPP_SEEN
#define {{namespace|upper}}_{{structname|upper}}_HPP_SEEN

#include <string>
#include <sml.hpp>
#include <cassert>

namespace {{namespace}} {

    struct {{structname}} {
        // states
        {% for s in machine.states %}
        {{ struct(s)|indent }}
        {% endfor %}

        // events
        {% for e in machine.events %}
        {{ struct(e)|indent }}
        {% endfor %}

        // event guards
        {% for eg in event_guards %}
        {{ event_method_decl(eg[0], eg[1])|indent }}
        {% endfor %}

        // actions
        {% for ea in event_actions %}
        {{ event_method_decl(ea[0], ea[1])|indent }}
        {% endfor %}

        // context

        {{ struct(context)|indent }}
        {{context.name}} ctx;

        auto operator()() {
            using namespace boost::sml;

            // clang-format off
            return make_transition_table(
{{ smltt_lambdas(machine.tt) }}
                );
            // clang-format on
        }

    };

    inline
    void test_{{structname}}() {
        namespace sml = boost::sml;
        sml::sm<{{structname}}> fsm{ {{structname}} {}};
        {% for et in test_fsm_events %}
        fsm.process_event({{namespace}}::{{structname}}::{{et[0]}} {});
        assert(fsm.is(sml::state<{{namespace}}::{{structname}}::{{et[1]}}>));
        {% endfor %}
    }

}

#endif // {{namespace|upper}}_{{classname|upper}}_HPP_SEEN
