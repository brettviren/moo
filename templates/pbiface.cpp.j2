// 100% generated, do not edit.


{% for iface in ifaces if iface.interface %}
// Data interface implementation for {{iface.name}} 
class WireCell::PB::{{iface.name}} : public WireCell::I{{iface.name}} {
  public:
    {{iface.name}}(const {{namespace.cpp}}::{{iface.name}}& o) : m_obj(o) { }
    virtual ~{{iface.name}}() { }

    {% for field in iface.fields %}
    {{field.cppfull}} {{field.name}}({{field.args}}) const {
        return m_{{field.name}};
    }
    {%- endfor %}

    {% for meth in iface.methods %}
    {{meth.cppfull}} {{meth.name}}({{meth.args}}) const;
    {% endfor %}

  private:
    
    {% for field in iface.fields %}
    {{field.cppfull}} m_{{field.name}};
    {% endfor %}
};
{% endfor %}


{% for iface in ifaces %}
// {{iface.name}}: fill PB object from iface pointer 
void WireCell::PB::fillpb(
    {{namespace.pb}}::{{iface.name}}& pbobj,
    const WireCell::I{{iface.name}}::pointer& ptr)
{
    {% for field in iface.fields %}
    {%- if field.shunt -%}
    {%- if field.repeated -%}
    {   // {{field.name}} copy as array
        auto vec = ptr->{{field.name}}();
        size_t siz = vec->size();
        RepeatedField<{{field.cpptype}}> pbattr;
        pbattr.Reserve(size);
        for (size_t ind=0; ind<size; ++ind) {
            pbattr[ind] = vec[ind];
        }
        pbobj.mutable_{{field.name}}()->Swap(&pbattr);        
    }
    {%- else -%}
    {   // {{field.name}} copy as scalar
        pbobj.set_{{field.name}}(ptr->{{field.name}}());
    }
    {%- endif %}
    {% else -%}
    {   // {{field.name}} hand-wired copy
        pbiface_fill_{{field.name}}(pbobj, ptr);
    }
    {% endif -%}
    {%- endfor %}
}
{% endfor %}

