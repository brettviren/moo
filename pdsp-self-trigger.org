#+title: Deconstruct the self trigger to provide input to nextgen message schema

PTMP message schema v0 consists entirely of using a ~TPSet~ object to represent *all* in-band information passed through the self-trigger system.  

The following figure shows connectivity between message processing node *types*.  Not all these nodes exist yet but the picture is approximately correct.

[[file:pdsp-self-trigger.png]]

All things labeled "TP", "TC" or "TD" are represented now with a message bearing a ~TPSet~ object despite these being semantically different concepts.  

* Pros/Cons of using one message type

Good things about homogeneous message schema:

- Reuse algorithms, eg Zipper and TPQuery, on messages which different
  semantically but share a common representation.  These algorithms
  need to interpret some portion of the message so if the message
  schema changes, different versions of the algorithms are needed, or
  some other mechanism to abstract the message portions needed.

- Simpler to understand a single message type than many.

Bad things about homogeneous message schema:

- It is confusing to some people to use the same data type to mean different things in different contexts.

- Some information needed in some contexts simply isn't represented.

- Some information not needed has vestigial stubs carried.

* Requirements on messages placed by components

** window 

This component repacks TPs into fixed window output TPSets based on
the ~tstart~ time.  As a side effect this performs a *turn around* on the
raw TPs from the HFs.  The HFs emit TPs based on their end time
(~tstart + tspan~) and the window re-emits them based on start time
(~tstart~).  The window algorithms requires:

- iteration of TPs
- reading ~TrigPrim.tstart~
- construct new ~TPSet~ objects (but not new ~TrigPrim~ objects) 

** zipper

This component passes through its input messages to its output
unchanged except in their relative order.  Tardy input messages are
dropped.  The zipper algorithm requires:

- reading ~TPSet.tstart~ and ~TPSet.detid~

** query

This component accepts and buffers its input messages and provides a
query service to return any that is buffered or may be buffered in the
future based on matching the ~TPSet.detid~ and a given time interval.
Any ~TPSet~ message returned by the service is identical to how it was
on input.
The query service requires:

- reading ~TPSet.detid~, ~TPSet.tstart~, ~TPSet.tspan~

** filter

This component runs some algorithm ("TC finder", "TD finder") which
selects on its input ~TPSet~ stream to produce an output ~TPSet~ with some
subset of ~TrigPrim~ objects.  The filter service requires

- destructive sink of ~TPSet~ and constructive source of ~TPSet~
- selected ~TrigPrim~ objects are left unmodified
- filter (engine) requires reading ~TPSet.detid~ and ~TPSet.tstart~
- filter (algorithm) may require access to all ~TPSet~ info
- some have called for adding semantic labels/tags

** mlt

A "MLT", per se, does not yet exist.  A zipper can be used as a dumb
version that simply passes all input in time order.  The plan is for
the MLT to output a message which only has the minimum needed to
indicate a TD.  Because the exact algorithm is not yet known, the
requirements can not be completed, but:

- presumably does not require ~TrigPrim~ level info
- will certainly need ~TPSet.tstart/.tspan~ and ~TPSet.detid~
- in full generality, will need to represent multiple "rectangular" regions in time/channel space.


