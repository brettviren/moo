<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-24 Sun 18:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>moo</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Brett Viren" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/darksun.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/hideshow.css"/>
<script type="text/javascript" src="export/styles/darksun/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/darksun.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/hideshow.js"></script>
<script type="text/javascript" src="export/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">moo
<br />
<span class="subtitle">Model Oriented Objects</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#intro">Introduction</a>
<ul>
<li><a href="#hello-codgen">Hello codegen</a>
<ul>
<li><a href="#hello-schema">Hello schema</a></li>
<li><a href="#hello-model">Hello model</a></li>
<li><a href="#org5bb7012">Hello template</a></li>
<li><a href="#hello-building">Hello building</a></li>
</ul>
</li>
<li><a href="#extended-example">Extended example</a></li>
</ul>
</li>
<li><a href="#schema">Schema</a>
<ul>
<li><a href="#jvjs">Jsonnet vs JSON Schema</a></li>
<li><a href="#composition">Composition</a></li>
<li><a href="#selection">Selection</a>
<ul>
<li><a href="#jsonnet-selection">Jsonnet selection</a></li>
<li><a href="#cli-selection">Command line selection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#models">Models</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#hello-building">Build</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd088ba3" class="outline-2">
<h2 id="intro">Introduction</h2>
<div class="outline-text-2" id="text-intro">
<p>
Model-oriented objects (moo) is a code generator (codegen).  A data
structure (the model) may be applied to a code <i>template</i> to produce
code.  This is a common approach and moo is particularly influenced by
the code generator <a href="https://github.com/zeromq/gsl">gsl</a> as it is applied to <a href="https://github.com/zeromq/zproto">zproto</a>/<a href="https://github.com/zeromq/zproject">zproject</a> templates
by the ZeroMQ community.
</p>

<p>
moo consists of these main aspects:
</p>

<ul class="org-ul">
<li>Schema is used to provide an explicit contract between <i>model</i> and
<i>template</i> developers.  moo provides support for developing schema
with <a href="https://jsonnet.org">Jsonnet</a> and supports the use of JSON, XML, YAML and various
other languages.  The resulting schema data structure is expected to
adhere to <a href="http://json-schema.org/">JSON Schema</a> and use of the moo Jsonnet support functions
assures this adherence by construction.</li>

<li>Models may be developed in the same variety of languages as schema
and moo provides support for developing them with <a href="https://jsonnet.org">Jsonnet</a> which,
tied with developing schema in Jsonnet, help to reduce errors by
making the model compliant by construction.</li>

<li>Templates are developed primarily in whatever language is intended
for the target code (C++, Python, LaTeX, GraphViz dot, etc).  moo
provides support for interspersing such files with directives
written in markup supported by <a href="https://jinja.palletsprojects.com">Jinja2</a>.</li>

<li>The <code>moo</code> Python module provides methods to handle all of the actions
involved in the codegen including compiling of Jsonnet to JSON,
reading Jsonnet, JSON, XML, YAML, etc into data structures,
validating of model data structure against schema data structure and
finally applying a model to a template to generate code.</li>

<li>The <code>moo</code> program exposes the same functionality to the command line.</li>

<li>A <a href="https://waf.io">Waf</a> build system example is provided which demonstrates how to
generate the tasks to generate code.</li>
</ul>

<p>
The moo package and tooling is layered to abstract the general support
needed to generate code from any domain-specific features and it
includes examples and support for some specific domains.
</p>

<p>
The remainder of this introduction provides a quick-start guide to
install the moo package and then walks through a simple "Hello
codegen!" example.  Remaining sections cover each main aspect listed above
</p>
</div>

<div id="outline-container-org45884af" class="outline-3">
<h3 id="hello-codgen">Hello codegen</h3>
<div class="outline-text-3" id="text-hello-codgen">
<p>
In this example we develop a trivial schema, a model that adheres to
the schema and a template that accepts schema-valid models.  We will
defer until later sections some aspects of real world complexity
including the use of multiple models, multiple templates, applying
model substructure, and handling complex codegen task patterns.
</p>

<p>
This process will be presented in a linear manner which progresses
through schema, model, template, codegen.  In real development one
should expect a more iterative process.  For example, during template
development it may be discovered that the current model is inadequate.
The schema would then modified and the model updated and then the
template may be changed.  As new templates are devised this iteration
may repeat.  The power of codegen comes by allowing the number of
templates to grow for a given schema while also allowing novel models
to be formed which immediately benefit from the available templates.
The factoring necessarily to achieve this power comes at a cost of
this iteration.  Strategies to manage this cost are given in later
sections.
</p>
</div>

<div id="outline-container-org616bae3" class="outline-4">
<h4 id="hello-schema">Hello schema</h4>
<div class="outline-text-4" id="text-hello-schema">
<p>
We start with the schema.  As said above, moo schema adheres to <a href="http://json-schema.org/">JSON
Schema</a> although we develop it in Jsonnet (really, who likes writing
JSON?).  Here is our "hello" schema
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ms = moo.schema;
ms.schema(
    ms.object(
        {
            name:ms.string(),
            url:ms.string(format=<span style="color: #e9b96e;">"uri"</span>)
        },
        required=[<span style="color: #e9b96e;">"name"</span>, <span style="color: #e9b96e;">"url"</span>]
    )
)
</pre>
</div>

<p>
A tutorial on Jsonnet won't be included here instead we point the
interested reader to the well written <a href="https://jsonnet.org/learning/tutorial.html">Jsonnet tutorial</a> and <a href="https://jsonnet.org/ref/stdlib.html">standard
library reference</a>.  But, one thing to take note of is the first line:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
</pre>
</div>

<p>
This <code>moo</code> Jsonnet module provides the functions used to assure the
resulting schema data structure adheres to JSON Schema.  It also
provides other helper functions.  The <a href="moo/moo.jsonnet">moo.jsonnet</a> file itself may be
found in the <code>moo</code> Python package directory.
</p>

<p>
We may compile this "hello" schema Jsonnet file using the C++ or Go
command line programs but the <code>moo</code> command is provided and brings some
additional convenience.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"$id"</span>: <span style="color: #e9b2e3;">null</span>,
    <span style="color: #b4fa70;">"$schema"</span>: <span style="color: #e9b96e;">"http://json-schema.org/draft-07/schema#"</span>,
    <span style="color: #b4fa70;">"definitions"</span>: {},
    <span style="color: #b4fa70;">"properties"</span>: {
        <span style="color: #b4fa70;">"name"</span>: {
            <span style="color: #b4fa70;">"$id"</span>: <span style="color: #e9b2e3;">null</span>,
            <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b2e3;">null</span>,
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        },
        <span style="color: #b4fa70;">"url"</span>: {
            <span style="color: #b4fa70;">"$id"</span>: <span style="color: #e9b2e3;">null</span>,
            <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        }
    },
    <span style="color: #b4fa70;">"required"</span>: [
        <span style="color: #e9b96e;">"name"</span>,
        <span style="color: #e9b96e;">"url"</span>
    ],
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"object"</span>
}
</pre>
</div>

<p>
This shows clearly the relative conciseness of Jsonnet compared to
JSON and that will become more substantial as our schemas become more
complex.
</p>

<p>
This "hello" schema describes a simple object of two attibutes, <code>name</code>
which is a string and a <code>url</code> which is also a string and of a particular
format.  This is JSON Schema language and to learn this simple
language, see <a href="http://json-schema.org/understanding-json-schema/">Understanding JSON Schema</a>.
</p>

<p>
By looking at the schema we may be tempted to guess what it describes.
We might guess it describes a bookmark entry or maybe an entry in a
personal contact manager or maybe an element of a configuration
system.  However, the schema does not determine any semantic meaning.
The model will provide actual values and that will more strongly hint
at meaning but ultimately it is the templates that express the final
nature.  It is important to hold this distinction in mind when
defining schema.  If a schema works for different purposes, there is
no reason to reinvent a new one just to satisfy different semantics.
</p>
</div>
</div>

<div id="outline-container-org96271d2" class="outline-4">
<h4 id="hello-model">Hello model</h4>
<div class="outline-text-4" id="text-hello-model">
<p>
Our first "hello" model is even simpler than the schema in both its
Jsonnet and JSON representation.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">{
    name: <span style="color: #e9b96e;">"moo home page"</span>,
    url : <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"name"</span>: <span style="color: #e9b96e;">"moo home page"</span>,
    <span style="color: #b4fa70;">"url"</span>: <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
}
</pre>
</div>

<p>
The values and the model file name now give hints as to semantic
meaning the modeler had in mind.  But the template developer only
cares that this model is valid against a schema.  We may use the <code>moo</code>
command line program to perform validation, relying on the Python
package <a href="https://python-jsonschema.readthedocs.io">jsonschema</a> for the heavy lifting.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
The lack of any error indicates validity.  We can disturb the model by
removing a required attribute key or providing a value of the wrong
type.  For example, let us change the <code>url</code> attribute value to hold the
integer <code>42</code>.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> hello = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"model_hp.jsonnet"</span>;
hello { url : 42 }
</pre>
</div>

<p>
Note, this takes the first model and overrides the <code>url</code> attribute with
a new one.  If the first model changes in orthogonal ways, this
derived model need not.  We can now determine that new model is no
longer valid against the schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp_invalid.jsonnet 2&gt;&amp;1 |tail -7
</pre>
</div>

<pre class="example">
jsonschema.exceptions.SchemaError: None is not of type 'string'

Failed validating 'type' in metaschema['properties']['$id']:
    {'format': 'uri-reference', 'type': 'string'}

On schema['$id']:
    None
</pre>
</div>
</div>

<div id="outline-container-org5bb7012" class="outline-4">
<h4 id="org5bb7012">Hello template</h4>
<div class="outline-text-4" id="text-org5bb7012">
<p>
It is the template where all this abstract rubber finally meets the
road.  With all the build of that abstraction, it is admittedly
anticlimactic to see some ways we put it to use.  It is only as
complexity increases that benefits will be paid.  For now, consider a
painfully trivial web site that merely holds a link:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
&lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">"{{url}}"</span>&gt;{{name}}&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo generate hello/model_hp.jsonnet hello/link.html.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
&lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>&gt;moo home page&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>

<p>
Or a simple command line tool that bakes in specific targets for download.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading {{name}}"</span>
wget -O <span style="color: #e9b96e;">"{{name}}"</span> <span style="color: #e9b96e;">"{{url}}"</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo generate hello/model_hp.jsonnet hello/downloader.sh.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading moo home page"</span>
wget -O <span style="color: #e9b96e;">"moo home page"</span> <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
</pre>
</div>


<p>
This example shows an obvious <i>semantic sheer</i> between what the model
developer and the template developer was thinking.  While the code
generation works perfectly, there are two interpretations of <code>name</code>.
The more restrictive the schema may be the stronger is the contract
between model and template developers.  In practice, the two will
often be one person and these sheers will be ironed out by extending
the schema and model to cover both semantic understandings or if the
sheer is too great, developing new or derived schema.
</p>
</div>
</div>

<div id="outline-container-org9798c0f" class="outline-4">
<h4 id="hello-building">Hello building</h4>
<div class="outline-text-4" id="text-hello-building">
<p>
This example is simple enough that command line invocations are
sufficient.  As our system of schema, models and templates grow, a
layer of automated task generation becomes rather welcome.  moo
provides a Waf-based example of that.  The main <a href="wscript">wscript</a> file may be
used as a starting point and our "hello" example provides a
<a href="hello/wscript_build">wscript<sub>build</sub></a> file showing how one may extend the main wscript to
handle domain-specific codegen.
</p>

<div class="org-src-container">
<pre class="src src-python">bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_link.html"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"link.html.j2"</span>))
bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_downloader.sh"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"downloader.sh.j2"</span>))
</pre>
</div>

<p>
And build:
</p>
<pre class="example">
$ waf configure
$ waf
$ ls build/hello_*
</pre>

<p>
This build is fairly simple and so each target is exhaustively listed.
As the number of targets grow we may exploit symmetries to codify the
Waf task generation.
</p>
</div>
</div>
</div>


<div id="outline-container-orge2fdb42" class="outline-3">
<h3 id="extended-example">Extended example</h3>
<div class="outline-text-3" id="text-extended-example">
<p>
As systems go, "hello" is fairly trivial.  The rest of this document
will use an extended example to illustrate how moo handles more
complexity and this section gives an overview of its parts.  
</p>

<p>
We consider a simple, distributed data processing system.  We
decompose the system into various conceptual <i>roles</i>.  To each role we
associate some semantic meaning and expected general behavior.  There
will be some commonalities across all roles or across a subset and we
will exploit their symmetry to simplify modeling while still
accommodating their own unique characteristics, interfaces, etc.
</p>

<p>
In generating code, we allow a role to have more than one
<i>implementation</i>.  In a sense, a role is an abstract conceptual (and
possibly literal) base class and an implementation is a similar,
concrete subclass.  In principle, any number of layers of this
conceptual inheritance may be employed but the example will stick to
one.
</p>

<p>
In final deployments, each implementation may have many <i>instances</i> (eg,
we may execute many copies of a program).  We will seek to take this
into account in our modeling.
</p>

<p>
To be more concrete consider a system which we will call PBC, named
after its three roles: a <b>producer</b> and a <b>consumer</b> and an intervening
<b>broker</b>.  Prior to any development we know some of what the result must
be able to do:
</p>

<ul class="org-ul">
<li>Connect the output of the producers and the input of the consumers to the brokers.</li>
<li>Define target language (eg, C++) object representations of the messages to be exchanged.</li>
<li>Develop object serialization methods which allow information to be transferred between instances of the roles.</li>
<li>Define finite state machines enacting implementation-specific behavior.</li>
<li>Configure each instance with their role-specific and implementation-specific configuration items.</li>
<li>Produce network topology diagrams and other documentation.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orga79dbb2" class="outline-2">
<h2 id="schema">Schema</h2>
<div class="outline-text-2" id="text-schema">
<p>
In moo, the schema provides a contract between model and template
developers.  JSON Schema is selected to provide a "meta-schema" to
which moo expect any schema data structures to adhere.  In <code>moo.jsonnet</code>
moo provides support to construct JSON Schema compliant structure in
Jsonnet.
</p>
</div>

<div id="outline-container-orgd5a7736" class="outline-3">
<h3 id="jvjs">Jsonnet vs JSON Schema</h3>
<div class="outline-text-3" id="text-jvjs">
<p>
To develop schema data structures with moo's Jsonnet, one should first
become familiar with JSON Schema itself.  The <a href="http://json-schema.org/understanding-json-schema/">Understanding JSON
Schema</a> document provides a fast and excellent learning resource.  A
large, if not complete, fraction of JSON Schema is reflected into
<code>moo.schema</code> functions.  Thus, one may learn JSON Schema and then map
its terms to functions provided by moo.
</p>

<p>
For example, a simple schema describing a string may be written in
JSON Schema as:
</p>

<div class="org-src-container">
<pre class="src src-json">{<span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>}
</pre>
</div>

<p>
and with moo's Jsonnet support as
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
moo.schema.string()
</pre>
</div>

<p>
As we saw in the "hello" example, moo Jsonnet function calls may be
nested to build up more complex, nested JSON Schema structure.
</p>
</div>
</div>

<div id="outline-container-orgbeff432" class="outline-3">
<h3 id="composition">Composition</h3>
<div class="outline-text-3" id="text-composition">
<p>
Both Jsonnet and JSON Schema have their own forms to compose structure
through <i>references</i>.  This allows defining structure in one place and
using it in multiple places.  Jsonnet references are resolved during
compilation while JSON Schema references are purely logical and
resolved by some interpreter (in case of moo, that's the <code>jsonschema</code>
Python module).  There are a number of trade-offs in selecting how to
employ references.
</p>

<p>
Jsonnet provides these reference idioms:
</p>

<ul class="org-ul">
<li>an object produced by one file may be referenced in another via <code>import</code>.</li>
<li>an object may be defined in a <code>local</code> variable and used multiple times within that file.</li>
<li>structure produced by a file may be referenced within the structure with <code>self</code> or <code>super</code> keywords and <code>$.</code> paths.</li>
</ul>

<p>
Here is a contrived example of these.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ss = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"subschema.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> sss = ss.subsubschema;
{
  <span style="color: #73d216;">// double colon isn't output</span>
  foo :: moo.schema.string(),
  moo.schema.schema($.foo)
  <span style="color: #73d216;">// or equivalently</span>
  <span style="color: #73d216;">// moo.schema.schema(self.foo)</span>
}
</pre>
</div>


<p>
The benefit of using Jsonnet references is that they are first class
elements of the Jsonnet language.  This means the Jsonnet compiler
will find mistakes.
</p>

<p>
A potential drawback is that the Jsonnet compiler resolves references
by replacing them with a copy of what they reference.  When the same
structure is referenced multiple times it leads to duplication in the
output.  Since no human need process the output this redundancy in the
output typically does not lead to any problems.  In some cases it may
lead to slower Jsonnet compile times.
</p>

<p>
However, a hard limitation of Jsonnet references is that they can not
express a recursive data structure without leading the compiler to run
forever or fail with a stack overflow. 
</p>

<p>
JSON Schema references are provided through a <i>special form</i>:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"&lt;path&gt;"</span> }
</pre>
</div>

<p>
This entire special form is replaced by the value associated to the
attribute found at <code>"&lt;path&gt;"</code> somewhere in the rest of the JSON.  By
convention, a <code>"&lt;path&gt;"</code> is expected to references an attribute under a
top level <code>"definitions"</code> attribute.  For example:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"#/definitions/target"</span> }
</pre>
</div>

<p>
would be replaced by <code>&lt;content&gt;</code> as found at:
</p>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"definitions"</span> : {
        <span style="color: #b4fa70;">"target"</span> : &lt;content&gt;
    }
}
</pre>
</div>

<p>
JSON Schema also provides way to define a target with an <code>$id</code> attribute
but this feature is currently unsupported by the Python module
<code>jsonschema</code> which moo relies on and we will discard it from
consideration.
</p>

<p>
In Jsonnet, the JSON Schema special form <code>{ "$ref" : "&lt;path&gt;" }</code> may be
created using a call to <code>moo.schema.ref(&lt;path&gt;)</code> and if the conventional
<code>"definitions"</code> is used then a shorter <code>moo.schema.ref("target")</code> may be
used.
</p>

<p>
In either case, it is required for the Jsonnet developer to assure that
<code>&lt;path&gt;</code> is included in the output.  The conventional <code>"definitions"</code> may be provided to <code>moo.schema.schema()</code> as an argument.
</p>
</div>
</div>

<div id="outline-container-org7c00947" class="outline-3">
<h3 id="selection">Selection</h3>
<div class="outline-text-3" id="text-selection">
<p>
Schema is described in a nested way with schema being composed of more
schema (it's schemas all the way down).  It will often be the case
that a model or a template or both require a schema which is embedded
in a larger schema.  moo allows selecting sub-schema in two ways:
through Jsonnet and on the command line.
</p>
</div>

<div id="outline-container-org344c8ed" class="outline-4">
<h4 id="jsonnet-selection">Jsonnet selection</h4>
<div class="outline-text-4" id="text-jsonnet-selection">
<p>
Jsonnet provides selection in the same way as composition, that is
through references.  One may construct a large schema in one Jsonnet
file and write a second Jsonnet file which imports the first and
exposes the desired subset.  The first may be written to assist in
this selection.  For example, if the main schema has:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> defs = {
    broker: { ... },
};
{
    defs:: defs,
    schema : moo.schema.schema(...)
}
</pre>
</div>

<p>
Then this Jsonnet file can evaluate to just the broker:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> main = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"schema.jsonnet"</span>;
main.defs.broker
</pre>
</div>
</div>
</div>

<div id="outline-container-org181d8cb" class="outline-4">
<h4 id="cli-selection">Command line selection</h4>
<div class="outline-text-4" id="text-cli-selection">
<p>
The <code>moo</code> command line provides a way to reference into schema (and
model) structure.  For example, the schema that governs the <code>url</code>
property of the top-level "hello" schema can be selected out during
compilation:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P properties.url hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"$id"</span>: <span style="color: #e9b2e3;">null</span>,
    <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
}
</pre>
</div>

<p>
The <code>moo</code> command also provides a way to simultaneously select a schema
path and a model path.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -D name -S properties.name -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
Again, lack of any error shows a successful validation.
</p>
</div>
</div>
</div>
</div>





<div id="outline-container-org7c7c956" class="outline-2">
<h2 id="models">Models</h2>
<div class="outline-text-2" id="text-models">
</div>
</div>


<div id="outline-container-orgfbed08e" class="outline-2">
<h2 id="templates">Templates</h2>
<div class="outline-text-2" id="text-templates">
</div>
</div>


<div id="outline-container-org3af5099" class="outline-2">
<h2 id="command">Command</h2>
<div class="outline-text-2" id="text-command">
</div>
</div>


<div id="outline-container-org470d3c2" class="outline-2">
<h2 id="python">Python</h2>
<div class="outline-text-2" id="text-python">
</div>
</div>


<div id="outline-container-org52d774c" class="outline-2">
<h2 id="hello-building">Build</h2>
<div class="outline-text-2" id="text-hello-building">
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Viren</p>
<p class="date">Created: 2020-05-24 Sun 18:55</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
