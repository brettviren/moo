<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-28 Thu 14:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>moo 無</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Brett Viren" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/darksun.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/hideshow.css"/>
<script type="text/javascript" src="export/styles/darksun/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/darksun.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/hideshow.js"></script>
<script type="text/javascript" src="export/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">moo 無
<br />
<span class="subtitle">Model Oriented Objects</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#intro">Introduction</a>
<ul>
<li><a href="#quickstart">Quick start</a></li>
<li><a href="#hello-codgen">Hello codegen</a>
<ul>
<li><a href="#hello-model">Hello model</a></li>
<li><a href="#orgd66740c">Hello template</a></li>
<li><a href="#hello-schema">Hello schema</a></li>
<li><a href="#hello-building">Hello build</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ex-codec">A codec</a></li>
<li><a href="#schema">Schema</a>
<ul>
<li><a href="#valid-v-assert">Validation vs assertion</a></li>
<li><a href="#js-v-js">Jsonnet vs JSON Schema</a></li>
<li><a href="#codec-schema">Codec schema</a></li>
</ul>
</li>
<li><a href="#models">Models</a>
<ul>
<li><a href="#mod-lang">Modeling languages</a></li>
<li><a href="#ccm-codec">Codec models</a></li>
<li><a href="#roles">Roles and their implementation</a></li>
</ul>
</li>
<li><a href="#templates">Templates</a>
<ul>
<li><a href="#cpp-class-tmpl">C++ class header template</a></li>
</ul>
</li>
<li><a href="#org25490ad">Forward</a>
<ul>
<li><a href="#factoring">Factoring</a></li>
<li><a href="#composition">Composition</a></li>
<li><a href="#selection">Selection</a>
<ul>
<li><a href="#jsonnet-selection">Jsonnet selection</a></li>
<li><a href="#cli-selection">Command line selection</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-intro" class="outline-2">
<h2 id="intro">Introduction</h2>
<div class="outline-text-2" id="text-intro">
<p>
Model-oriented objects (<b>moo</b>) generates code by applying a code
<i>template</i> to a data structure (the model).  
</p>

<div class="org-center">
<p>
\(moo(M, T) \to C\)
</p>
</div>

<p>
This is an age old idea and <b>moo</b> is particularly influenced by the code
generator <a href="https://github.com/zeromq/gsl">gsl</a> as it is applied to <a href="https://github.com/zeromq/zproto">zproto</a>/<a href="https://github.com/zeromq/zproject">zproject</a> templates by the
ZeroMQ community to generate client, servers, protocols and entire
software projects.  <b>moo</b>'s contributions to this idea include:
</p>

<ul class="org-ul">
<li>support for defining models in essentially any data language that
can produce valid data structure, specifically all supported by the
<a href="https://github.com/ssato/python-anyconfig">anyconfig</a> Python package (JSON, YAML, XML, INI, etc).</li>

<li>special support for defining models in the <a href="https://jsonnet.org">Jsonnet</a> data language.</li>

<li>support for defining model schema in the vocabulary of <a href="http://json-schema.org/">JSON Schema</a>.
Schema may be developed in all the same languages as models and <b>moo</b>
provides special support for Jsonnet, including a Jsonnet interface
to JSON Schema vocabulary.</li>

<li>defining templates in the <a href="https://jinja.palletsprojects.com">Jinja2</a> template markup used in many other
projects.</li>

<li>a command line, Python modules and example <a href="https://waf.io">Waf</a> build system that
shows how one may compile, , validation and render models into code
and build and test that code.</li>
</ul>

<p>
The change in languages adopted by <b>moo</b> is expected to enable better
project factoring, model and template reuse and easier development.
</p>
</div>


<div id="outline-container-quickstart" class="outline-3">
<h3 id="quickstart">Quick start</h3>
<div class="outline-text-3" id="text-quickstart">
<p>
The <code>moo</code> command line and Python module is provided as a Python
package and is installed in the "usual way".  Here is one:
</p>

<pre class="example">
$ git clone https://github.com/brettviren/moo.git
$ python3 -m venv venv
$ source venv/bin/activate
$ pip install -e .
$ moo --help
$ moo validate --help
$ moo validate moo/moo.jsonnet
</pre>
</div>
</div>

<div id="outline-container-hello-codgen" class="outline-3">
<h3 id="hello-codgen">Hello codegen</h3>
<div class="outline-text-3" id="text-hello-codgen">
<p>
In this example we develop a trivial schema, a model that adheres to
the schema and a template that accepts schema-valid models.  We defer
any explanation until later sections.
</p>
</div>

<div id="outline-container-hello-model" class="outline-4">
<h4 id="hello-model">Hello model</h4>
<div class="outline-text-4" id="text-hello-model">
<p>
Our first "hello" model is very simple.  
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">{
    name: <span style="color: #e9b96e;">"moo home page"</span>,
    url : <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>,
}
</pre>
</div>

<p>
This example is so simple that the use of Jsonnet rather than base
JSON seems like overkill.  However, for anyone that has ever had to
write raw JSON, simply being able to drop quotes around keys and leave
in a final comma makes Jsonnet so much more human friendly.  As our
models grown in complexity we will see how Jsonnet becomes even more
useful and how <b>moo</b> provides some additional help.
</p>

<p>
We can <i>compile</i> the Jsonnet to JSON with the <code>moo</code> command line program:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"name"</span>: <span style="color: #e9b96e;">"moo home page"</span>,
    <span style="color: #b4fa70;">"url"</span>: <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
}
</pre>
</div>

<p>
That's it.  That's our boring object.  Next, let's put it to use.
</p>
</div>
</div>

<div id="outline-container-orgd66740c" class="outline-4">
<h4 id="orgd66740c">Hello template</h4>
<div class="outline-text-4" id="text-orgd66740c">
<p>
It is the template where the abstract model is made real.  We may
write many types of templates that all accept many models which adhere
to a particular schema.  Here we show two.
</p>

<p>
First is a simple web page which interprets the model as an HTML link.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
  &lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">"{{model.url}}"</span>&gt;{{model.name}}&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>

<p>
Note the model data structure is available as a Jinja2 parameter
<code>model</code>.  Other parameters may be included, for example, <b>moo</b> will pass
in a <code>moo</code> parameter holding a helpful data structure and we will see
this used in the codec example.
</p>

<p>
We may <i>render</i> the template against the model with the <code>moo</code> command line
program:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo render hello/model_hp.jsonnet hello/link.html.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
  &lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>&gt;moo home page&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>

<p>
A boring web page for a boring model.
</p>

<p>
The second "hello" example template is a simple command line tool that
bakes in specific targets for download.
</p>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading {{model.name}}"</span>
wget -O <span style="color: #e9b96e;">"{{model.name}}"</span> <span style="color: #e9b96e;">"{{model.url}}"</span>
</pre>
</div>

<p>
It is rendered with:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo render hello/model_hp.jsonnet hello/downloader.sh.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading moo home page"</span>
wget -O <span style="color: #e9b96e;">"moo home page"</span> <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-hello-schema" class="outline-4">
<h4 id="hello-schema">Hello schema</h4>
<div class="outline-text-4" id="text-hello-schema">
<p>
In <b>moo</b>, schema is used to specify how a valid model must be
structured in order to form a contract between model and template
developers.
</p>

<p>
Here is our "hello" schema which may validate our "hello" model:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ms = moo.schema;
<span style="color: #b4fa70;">local</span> top = ms.schema(ms.object({
    name:ms.string(),
    url:ms.string(format=<span style="color: #e9b96e;">"uri"</span>)
}, required=[<span style="color: #e9b96e;">"name"</span>, <span style="color: #e9b96e;">"url"</span>]));
std.prune(top)
</pre>
</div>

<p>
We start to see some non-trivial Jsonnet.  A tutorial on Jsonnet won't
be included here instead we point the interested reader to the well
written <a href="https://jsonnet.org/learning/tutorial.html">Jsonnet</a>
tutorial and <a href="https://jsonnet.org/ref/stdlib.html">standard</a> library
reference.  
</p>

<p>
One thing to take note of is the first line:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
</pre>
</div>

<p>
This <code>moo.jsonnet</code> module provides all of <b>moo</b>'s extra support for
Jsonnet.  For most schema and models developed in Jsonnet it will be
helpful to use.  It is found in the <code>moo</code> Python package directory and
is located automatically by the <code>moo</code> command line program.  The user
may provide their own Jsonnet libraries.
</p>

<p>
Like with a model file we may compile a schema file to JSON with the <code>moo</code> command line program:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"$schema"</span>: <span style="color: #e9b96e;">"http://json-schema.org/draft-07/schema#"</span>,
    <span style="color: #b4fa70;">"properties"</span>: {
        <span style="color: #b4fa70;">"name"</span>: {
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        },
        <span style="color: #b4fa70;">"url"</span>: {
            <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        }
    },
    <span style="color: #b4fa70;">"required"</span>: [
        <span style="color: #e9b96e;">"name"</span>,
        <span style="color: #e9b96e;">"url"</span>
    ],
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"object"</span>
}
</pre>
</div>

<p>
This is example of a JSON document that follows the vocabulary of JSON
Schema.  We won't give a tutorial on JSON Schema either but is a simple vocabulary and the reader is suggested to read the document <a href="http://json-schema.org/understanding-json-schema/">Understanding JSON Schema</a>.
</p>

<p>
This "hello" schema will accept a model as valid if it has two
attributes: <code>name</code> which has a value of string and <code>url</code> which is also
a string following a particular format.
</p>

<p>
We may use the <code>moo</code> command line program to perform validation of the
"hello" model against this schema.  It relies on the Python package <a href="https://python-jsonschema.readthedocs.io">jsonschema</a>
for the heavy lifting and its coverage of JSON Schema specification.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
The lack of any error here indicates validity.  We can disturb the
model by removing a required attribute key or providing a value of the
wrong type.  For example, let us change the <code>url</code> attribute value to
hold the integer <code>42</code>.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> hello = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"model_hp.jsonnet"</span>;
hello { url : 42 }
</pre>
</div>

<p>
Note, this uses a Jsonnet language feature to reuse first model and
override just its <code>url</code> attribute with a new one.  If the first model
changes in orthogonal ways, this derived model need not.  In any case,
we can now determine that new model is no longer valid against the
schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp_invalid.jsonnet 2&gt;&amp;1 |tail -7
</pre>
</div>

<pre class="example">
jsonschema.exceptions.ValidationError: 42 is not of type 'string'

Failed validating 'type' in schema['properties']['url']:
    {'format': 'uri', 'type': 'string'}

On instance['url']:
    42
</pre>
</div>
</div>

<div id="outline-container-hello-building" class="outline-4">
<h4 id="hello-building">Hello build</h4>
<div class="outline-text-4" id="text-hello-building">
<p>
This example is simple enough that command line invocations are
sufficient.  As our system of schema, models and templates grow, a
layer of automated task generation becomes rather welcome.  <b>moo</b>
provides a Waf-based example of that.  The main
<a href="wscript"><code>wscript</code></a> file may be used as a starting point and our
"hello" example provides a <a href="hello/wscript_build"><code>wscript_build</code></a>
file showing how one may extend the main wscript to handle
domain-specific codegen.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #73d216;"># </span><span style="color: #73d216;">of course this itself should be generated....</span>

bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_link.html"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"link.html.j2"</span>))
bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_downloader.sh"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"downloader.sh.j2"</span>))
</pre>
</div>

<p>
And build:
</p>
<pre class="example">
$ waf configure
$ waf
$ ls build/hello_*
build/hello_downloader.sh  build/hello_link.html
</pre>

<p>
This build is fairly simple and so the <code>wscript_build</code> file is
hand-crafted.  Clearly the right thing to do is to "render" a <b>moo</b>
model into a set of Waf tasks.  In this case instead of using a Jinja2
template, Waf task generator would be developed that directly
interpreters <b>moo</b> models and spawns the tasks.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-ex-codec" class="outline-2">
<h2 id="ex-codec">A codec</h2>
<div class="outline-text-2" id="text-ex-codec">
<p>
This section uses <b>moo</b> to develop an extended (although for now
rather incomplete) example to show more of what may be accomplished
with <b>moo</b>.  We describe the project and then dive into its schema,
models and templates and end with some ideas for where to go next.
</p>

<p>
The goal of the project will be to generate code which implements a
<i>codec</i>.  Here, a codec means software that can serialize a data
structure represented as native language types (eg a C++ <code>struct</code>)
into a series of bytes (encode) and from a properly encoded series of
bytes reproduce the structure (decode).  One way to illustrate a codec
is shown in the following diagram:
</p>


<div class="figure">
<p><object type="image/svg+xml" data="./codec.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
The <i>recv</i> represents a source of encoded data or <i>messages</i> (eg a
socket) and likewise the <i>send</i> is a sink.  The codec will define a
number of different <i>types</i> of messages.  In the diagram, the data
structure held in the messages is represented by the <i>fields</i> node.
The <i>id</i> is a special field made explicit and is used to represent the
message type or the mapping between encoding and structure.  The
<i>setters</i> and <i>getters</i> represent field accessor methods such as may
be used by an application to modify or query the current value held in
the codec.
</p>

<p>
In general, a codec will have multiple, related message types.  It is
likely that they will share some fields which are identical in name,
type and semantic meaning.  There are two extremes in how one may
realize this
</p>

<p>
The first extreme presents the <i>fields</i> as a flat set of attributes
where only those attributes which are mapped to the current <i>id</i> are
considered valid for calling.  The codec API then provides one
<i>getter</i> and one <i>setter</i> method for the union of fields across all
supported messages.  This is the idiom adopted by ZeroMQ Zproto and
has a benefit in minimizing copies.  Assuring only accessors
associated with the current <i>id</i> are accessed is troublesome for
hand-crafted code but as Zproto also generated most of the
application, this collusion is easy to assure in practice.
</p>

<p>
The other extreme is to maintain strict one-to-one mapping between
message type and a native language type (typically a <code>struct</code> or
<code>class</code>).  The codec API then provides one <i>getter</i> and one <i>setter</i>
for each message type which allows atomic access to the corresponding
native language type.  This is the idiom of, for example, use of
Protobuf serialization.  The explicit retaining of an atomic object is
convenient for hand-crafted code.  It does require more copying and
tends to encourage the serialization objects to permeate through
application code.
</p>

<p>
The concerns in the development of our fledgling codec include:
</p>

<dl class="org-dl">
<dt>schema</dt><dd>we will expect our models to describe messages types in
terms of an <i>id</i> of type string and a <i>body</i> which is specified as a
schema.</dd>

<dt>model</dt><dd>our model will describe various message types such as may
be used to enact control, configuration and monitoring (CCM) of a
distributed system</dd>

<dt>templates</dt><dd>we will make templates to define C++ types
corresponding to each message, C++ functions to serialize them using
at least two methods (JSON and MessagePack), test code,
documentation, etc.  (But, really, for now we merely render message
type models to their C++ <code>struct</code>)</dd>
</dl>
</div>
</div>

<div id="outline-container-schema" class="outline-2">
<h2 id="schema">Schema</h2>
<div class="outline-text-2" id="text-schema">
<p>
This section gives details on <b>moo</b> schema in the context of the codec
example
</p>
</div>

<div id="outline-container-valid-v-assert" class="outline-3">
<h3 id="valid-v-assert">Validation vs assertion</h3>
<div class="outline-text-3" id="text-valid-v-assert">
<p>
The primary purpose of a schema document in <b>moo</b> is to provide a
<i>contract</i> between model and template developers.  We wish to write
\(N_M\) models which may be applied to \(N_T\) templates.  An implicit
contract must be validated by looking for errors in \(N_M \times N_T\)
renderings.  By insinuating an explicit contract, many errors can be
detected in \(N_M\) validations against the schema.  For this use we
write data structures in the vocabulary of JSON Schema.
</p>

<p>
The second use of schema in <b>moo</b> is to assert structure for the
purpose of generating its implementation.  For example, we want to
render a model of a codec message type into a C++ <code>struct</code>.  Unlike
validation which may need to be more accepting, schema to assert
structure must not have any ambiguity.  
</p>

<p>
A subset of JSON Schema vocabulary may be used to assert unambiguous
schema, however it has two practical problems.  First, it adds extra
layers of structure in order to support meta information (eg, the
<code>"requires"</code> and <code>"parameters"</code> keywords of a JSON Schema <code>object</code>).
Iterating models with this extra structure puts a fairly large burden
on template development.  The second problem is that JSON Schema
vocabulary only supports the data types found in JSON (array, object,
string, number, Boolean).  To generate code we need a more expressive
set of types (eg, "unsigned 64 bit integer").  JSON Schema <code>object</code>
could be extended to include non-standard keywords to support these
extensions.  However, we may provide this extension more simply and
solve the first problem by developing our own assertion schema (which
we do below in <a href="#models">Models</a>).
</p>
</div>
</div>

<div id="outline-container-js-v-js" class="outline-3">
<h3 id="js-v-js">Jsonnet vs JSON Schema</h3>
<div class="outline-text-3" id="text-js-v-js">
<p>
With <b>moo</b> we may provide data structures represented in many languages.
Any language format supported by the <code>anyconfig</code> Python module or any
language that may produce such formats may be used.  In particular,
<b>moo</b> provides support for creating data structures for <b>moo</b> using
Jsonnet.  The reason why such variety can be supported by <b>moo</b> is that
schema validation, application of model to template and other
operations all occur on data structures in memory.  Populating those
structures from a particular persistent representation is factored out
and parameterized by the format.  This may be extended in the future
to support data structures loaded from SQL or noSQL type stores.
</p>

<p>
Thus, to develop your own schema data structures with <b>moo</b>'s Jsonnet,
first spend some quality time with
<a href="http://json-schema.org/understanding-json-schema/">Understanding
JSON Schema</a>.  This document provides a fast and excellent learning
resource to understand JSON Schema.  A large, if not complete,
fraction of JSON Schema is reflected into <code>moo.schema</code> functions so as
you learn JSON Schema focus on structure not on syntax and you may
then map JSON Schema keywords into <b>moo</b> Jsonnet functions.
</p>

<p>
As we will see used next, <b>moo</b> Jsonnet also provides additional schema
to more exactly specify types including attributes for numeric sizes,
formats, units.
</p>
</div>
</div>

<div id="outline-container-codec-schema" class="outline-3">
<h3 id="codec-schema">Codec schema</h3>
<div class="outline-text-3" id="text-codec-schema">
<p>
Here is an outline of a schema which broadly specifies a codec for the
purpose of this example:
</p>

<ul class="org-ul">
<li>A codec has some number of message types and each type has an attribute:</li>
<li><code>ident</code> giving a unique message type identifier and</li>
<li><code>body</code> which holds schema describing the structure of the message payload.</li>
</ul>

<p>
Based on such a schema, a number of models are developed each of which
a number of message types and each of those which provides an <code>ident</code>
value and a <code>body</code> schema.  And, with the schema in hand, a variety of
templates are developed which may generate code given any one of these
models.
</p>

<p>
In practice, a codec typically goes further to specify in detail how
every bit of schema maps to a byte stream.  We will leave this as an
implementation detail left to a <i>serialization</i> method chosen by the
template.  This means that we do not expect to convert an data object
produced by code generated from one model/template pair to necessarily
be compatible with code generated from the same model but a different
template.  Instead, we will need to organize templates into compatible
categories.  For example, one template may produce C++ native types
structure which may be shared by a variety of templates producing
individual serialization methods.  An application must take care to
match both ends of a data stream with matching serialization but may
use the same model.  OTOH, we may also produce Python native types
which are compatible with C++ native types when joined by suitably
matching Python and C++ ends of serialization methods.
</p>

<p>
In any case, in a formal <b>moo</b> Jsonnet schema the codec schema can be
defined as:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ms = moo.schema;
<span style="color: #b4fa70;">local</span> mt = moo.types;
{
    ident: ms.string(),
    body: ms.jsonschema(),
    mtype: ms.object({ident:$.ident,body:$.body}, [<span style="color: #e9b96e;">"ident"</span>]),
    codec: ms.array($.mtype),

    schema : std.prune($.codec),

    types :: mt + {
        timestamp: { issued: mt.timestamp(<span style="color: #e9b96e;">"i8"</span>, <span style="color: #e9b96e;">"ms"</span>)},
        mtype(name,body):: {ident:name, body:body },
    }
}
</pre>
</div>

<p>
We expose sub-schema (eg <code>mtype</code>) so that this schema may be easily
reused in other, larger schema.  We take the convention that the
"final result" schema for this file is found as the keyword <code>schema</code>.  
</p>

<p>
The <code>body</code> keyword is set to the output of <code>moo.schema.jsonschema()</code>.
This says that any valid model may provide a value for a <code>body</code> keyword
which is itself some form of valid JSON Schema.  This is a rather
open-ended contract which still puts a burden on template developers
to implement any valid JSON Schema structure.  With that challenge
overcome, one may then have a fully generic (up to requiring the
<code>ident</code>) system.  We can lighten the burden by applying more
"opinionated" schema for <code>body</code>.  For example, we may limit the <code>body</code> to
specify it as a "flat" object with its attributes only consisting of
scalar strings and numbers.  For this codec example, we will "cheat"
and say that the models and the templates will share an unspecified
sub-contract which keep structure simple in hopes that some future
development brings wealth of full generality.
</p>

<p>
Another detail to note is the use of <code>std.prune()</code> in defining the final
schema.  This reduction removes any <code>null</code> entries that may arise.  For
example, a <code>string()</code> takes an optional <code>format</code> argument which defaults
to <code>null</code>.  We can bury this inside each Jsonnet schema function but its
repeated call tends to degrade performance compared to a one-time
traversal of the final data structure.
</p>

<p>
To drop down one level of meta, here is the codec schema compiled to
JSON Schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P schema codec/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"items"</span>: {
        <span style="color: #b4fa70;">"properties"</span>: {
            <span style="color: #b4fa70;">"body"</span>: {
                <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"https://json-schema.org/draft-07/schema"</span>
            },
            <span style="color: #b4fa70;">"ident"</span>: {
                <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
            }
        },
        <span style="color: #b4fa70;">"required"</span>: [
            <span style="color: #e9b96e;">"ident"</span>
        ],
        <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"object"</span>
    },
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"array"</span>
}
</pre>
</div>


<p>
Note how JSON Schema '$ref' keyword is used to refer to schema held
externally to avoid having to copy its contents.  
</p>

<p>
We may also validate this schema with the <code>moo validate</code> command.  In
general this command takes a <code>-s/--schema</code> option to set the schema
against which we validate the argument (eg a file holding a model).
Here, our schema file is the argument and we rely on the default
validation schema to be JSON Schema itself, represented <b>as</b> JSON
Schema, no less and just as we see used in the <code>body</code> attribute.  We see
the convoluted recursion in full force here, but in the end it all
works:.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate codec/schema.jsonnet
</pre>
</div>

<pre class="example">

</pre>

<p>
No news is good news.
</p>
</div>
</div>
</div>


<div id="outline-container-models" class="outline-2">
<h2 id="models">Models</h2>
<div class="outline-text-2" id="text-models">
<p>
In <b>moo</b>, a model is a data structure which describes some abstract
"thing" (object) with the goal that it may be applied to one or more
templates in order to generate code.  A model should adhere to (be
validated by) a schema.
</p>
</div>

<div id="outline-container-mod-lang" class="outline-3">
<h3 id="mod-lang">Modeling languages</h3>
<div class="outline-text-3" id="text-mod-lang">
<p>
Just as with a schema, a developer may define a model in many data
languages.  <b>moo</b> supports models written in JSON, XML, YAML, and
various others (anything supported by the <code>anyconfig</code> Python module).
And of course developers are free to develop models in any form that
may generate these formats.  What ultimately matters is the in-memory
model data structure.
</p>

<p>
That variety aside, <b>moo</b> provides special support for defining models
in Jsonnet.  In particular, it provides functions to help create a
model in ways that assure consistent forms across models and in ways
that tend to produce models which are, by construction, valid against
schema.
</p>

<p>
In a properly constructed <b>moo</b> <code>schema.jsonnet</code> file, these functions are
available under the <code>.types</code> attribute.  It should extend the <code>.types</code>
structure from any inherited schema starting with what is provided by
<code>moo.jsonnet</code>.  Unlike the structure under <code>.schema</code>, the structure
provided by <code>.types</code> functions is assertive and not used for validation.
</p>
</div>
</div>

<div id="outline-container-ccm-codec" class="outline-3">
<h3 id="ccm-codec">Codec models</h3>
<div class="outline-text-3" id="text-ccm-codec">
<p>
Here is a very simple codec for controlling, configuring and
monitoring a distributed system.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> codec = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"codec/schema.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ct = codec.types;

<span style="color: #73d216;">// This model wants every message type to carry some common fields</span>
<span style="color: #b4fa70;">local</span> mtype(ident, payload={}) = ct.mtype(ident, ct.timestamp + payload);

std.prune([
    mtype(<span style="color: #e9b96e;">"config"</span>, {role:ct.str(), cfgid: ct.str()}),
    mtype(<span style="color: #e9b96e;">"start"</span>),
    mtype(<span style="color: #e9b96e;">"stop"</span>),
    mtype(<span style="color: #e9b96e;">"log"</span>, {level: ct.str(), message: ct.str()}),
])
</pre>
</div>

<p>
Consider the <code>"config"</code> message type for which we can individually show
as JSON Schema like:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P 0 ccm/model.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"body"</span>: {
        <span style="color: #b4fa70;">"cfgid"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"issued"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b2e3;">0</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"i8"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"num"</span>,
            <span style="color: #b4fa70;">"unit"</span>: <span style="color: #e9b96e;">"ms"</span>
        },
        <span style="color: #b4fa70;">"role"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        }
    },
    <span style="color: #b4fa70;">"ident"</span>: <span style="color: #e9b96e;">"config"</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-roles" class="outline-3">
<h3 id="roles">Roles and their implementation</h3>
<div class="outline-text-3" id="text-roles">
<p>
Real systems will have many entities to configure.  Considering the
system from a top-down view, we may define a number of abstract
"roles" that the entities enact and we will specify some portion of a
configuration object schema to be supported by a role.  With bottom-up
consideration we know that each implementation of any given entity
will need specific configuration parameters and thus also contribute
to the specification of configuration structure.
</p>

<p>
In this example we leave that "subclassing" to some external entity
which is resolved by the <code>"cfgid"</code>.  Its value is perhaps used by the
entity as a key to look up a full configuration in some database.  
</p>

<p>
With more effort now, we may instead handle this complexity directly
in our model.  We could remove <code>"cfgid"</code> and instead model a <code>"config"</code>
like message type for every implementation.  If the role-level
configuration is substantial, we'd like to factor it out or derive
from this base model to produce a per-implementation config.  
</p>

<p>
We show this latter technique with this contrived example:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> codec = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"codec/schema.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ct = codec.types;
<span style="color: #b4fa70;">local</span> parent = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"model.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> cfg = parent[0];

cfg {
    body: <span style="color: #b4fa70;">super</span>.body {
        favorite_color: ct.str(def=<span style="color: #e9b96e;">"purple"</span>),
    }
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo compile ccm/server.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"body"</span>: {
        <span style="color: #b4fa70;">"cfgid"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"favorite_color"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">"purple"</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"issued"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b2e3;">0</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"i8"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"num"</span>,
            <span style="color: #b4fa70;">"unit"</span>: <span style="color: #e9b96e;">"ms"</span>
        },
        <span style="color: #b4fa70;">"role"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        }
    },
    <span style="color: #b4fa70;">"ident"</span>: <span style="color: #e9b96e;">"config"</span>
}
</pre>
</div>

<p>
The same template that can consume each of the message type models in
<code>ccm/model.jsonnet</code> will be able to consume this contrived specialized
implantation called "server".
</p>
</div>
</div>
</div>


<div id="outline-container-templates" class="outline-2">
<h2 id="templates">Templates</h2>
<div class="outline-text-2" id="text-templates">
<p>
In <b>moo</b>, templates are files written in some target language with
Jinja2 markup interspersed.  A template applied to a model to generate
code in that target language.  The template is developed with the
model's schema in mind.
</p>
</div>

<div id="outline-container-cpp-class-tmpl" class="outline-3">
<h3 id="cpp-class-tmpl">C++ class header template</h3>
<div class="outline-text-3" id="text-cpp-class-tmpl">
<p>
This section extends the CCM codec example but with a template that is
in principle generic to any codec model.  The first template to
illustrate is one that generates a native language C++ type for a
model of a message type.
</p>

<div class="org-src-container">
<pre class="src src-c++">{%- macro defval(p) -%}
{% <span style="color: #b4fa70;">if</span> p.mootype == <span style="color: #e9b96e;">"str"</span> %}<span style="color: #e9b96e;">"{{ p.def }}"</span>{% <span style="color: #b4fa70;">else</span> %}{{ p.def }}{% endif %}
{%- endmacro -%}
<span style="color: #73d216;">// </span><span style="color: #73d216;">The message type {{ident}}</span>
<span style="color: #e090d7;">#if</span><span style="color: #e090d7;">n</span><span style="color: #e090d7;">def</span> {{model.ident|upper}}
<span style="color: #e090d7;">#define</span> {{model.ident|upper}}

<span style="color: #b4fa70;">struct</span> {{model.ident}} {
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">ident</span> = <span style="color: #e9b96e;">"{{model.ident}}"</span>;
    {% <span style="color: #b4fa70;">for</span> n,p <span style="color: #8cc4ff;">in</span> <span style="color: #fcaf3e;">model</span>.body.items() %}
    {{ moo.lang.cpp[p.mootype][p.dtype] }} {{ n }} = {{ defval(p) }};
    {% endfor %}
};
<span style="color: #e090d7;">#endif</span> <span style="color: #73d216;">// </span><span style="color: #73d216;">{{ident|upper}}</span>
</pre>
</div>


<p>
And, when we apply the first <code>"config"</code> message type model by selecting
the zeroth element of the full model:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo render -P 0 ccm/model.jsonnet codec/mtype.hpp.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">The message type </span>
<span style="color: #e090d7;">#if</span><span style="color: #e090d7;">n</span><span style="color: #e090d7;">def</span> CONFIG
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">CONFIG</span>

<span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">config</span> {
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">ident</span> = <span style="color: #e9b96e;">"config"</span>;
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">cfgid</span> = <span style="color: #e9b96e;">""</span>;
    <span style="color: #8cc4ff;">int64_t</span> <span style="color: #fcaf3e;">issued</span> = 0;
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">role</span> = <span style="color: #e9b96e;">""</span>;
};
<span style="color: #e090d7;">#endif</span> <span style="color: #73d216;">// </span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org25490ad" class="outline-2">
<h2 id="org25490ad">Forward</h2>
<div class="outline-text-2" id="text-org25490ad">
</div>
<div id="outline-container-factoring" class="outline-3">
<h3 id="factoring">Factoring</h3>
<div class="outline-text-3" id="text-factoring">
<p>
This codec example remained very simple and very incomplete.  Now,
that it is presented it should be clear more work is needed.  As the
scope of the development increases so will the complexity.  Some
factoring and reuse is needed.  For example:
</p>

<ul class="org-ul">
<li>A class header file template should take a model which combines
information about a the file, C++ namespace and finally the actual
class.</li>

<li>Such a model should be validated against a schema which is similarly
factored into file, namespace and class declaration sub-schema.</li>

<li>The template should be similarly factored using macros so these
macros may be reused in different template contexts.</li>

<li>The file model would be used in a <code>wscript_build.j2</code> macro to add
Waf build tasks.</li>
</ul>
</div>
</div>

<div id="outline-container-composition" class="outline-3">
<h3 id="composition">Composition</h3>
<div class="outline-text-3" id="text-composition">
<p>
Both Jsonnet and JSON Schema have their own forms to <i>compose</i> structure
through <i>references</i>.  This allows defining structure in one place and
using it in multiple places.  Jsonnet references are resolved during
compilation while JSON Schema references are purely logical and
resolved by some interpreter (in case of <b>moo</b>, that's the <code>jsonschema</code>
Python module).  There are a number of trade-offs in selecting how to
employ references.
</p>

<p>
Jsonnet provides these idioms for composing structure with references:
</p>

<ul class="org-ul">
<li>an object produced by one file may be referenced in another via
<code>import</code>.</li>

<li>an object may be defined in a <code>local</code> variable and used multiple
times within that file.</li>

<li>structure produced by a file may be referenced within the structure
with <code>self</code> or <code>super</code> keywords and <code>$.</code> paths.</li>
</ul>

<p>
The benefit of using Jsonnet references is that they are first class
elements of the Jsonnet language.  This means the Jsonnet compiler
will find mistakes.
</p>

<p>
A potential drawback is that the Jsonnet compiler resolves references
by replacing them in the output with a copy of what they reference.
When the same structure is referenced multiple times it leads to
duplication in the output.  Since no human need process the output
this (perfect) redundancy in the output typically does not lead to any
problems.  In some cases when the Jsonnet is very large and there are
costly Jsonnet function calls repeated in the structure, the
compilation time may be noticeably or even prohibitively slower.
</p>

<p>
There is one hard limitation in Jsonnet references and that is that
they must not be used to form a recursive data structure.  This will
lead to compilation errors (stack overflow).
</p>

<p>
With a much different syntax, JSON Schema references are provided
through a <i>special form</i> in the JSON:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"&lt;path&gt;"</span> }
</pre>
</div>

<p>
This entire special form, including the <code>{}</code>'s, is replaced by the value
associated to the attribute found at <code>"&lt;path&gt;"</code> somewhere in the rest of
the JSON.  By convention, a <code>"&lt;path&gt;"</code> is expected to references an
attribute under a top level <code>"definitions"</code> attribute.  For example:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"#/definitions/target"</span> }
</pre>
</div>

<p>
would be replaced by <code>&lt;content&gt;</code> as found at:
</p>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"definitions"</span> : {
        <span style="color: #b4fa70;">"target"</span> : &lt;content&gt;
    }
}
</pre>
</div>

<p>
JSON Schema also provides way to define a target with an <code>$id</code> attribute
but this feature is currently unsupported by the Python module
<code>jsonschema</code> which <b>moo</b> relies on and we will discard it from
consideration.
</p>

<p>
In Jsonnet, the JSON Schema special form <code>{ "$ref" : "&lt;path&gt;" }</code> may be
created using a call to <code>moo.schema.ref(&lt;path&gt;)</code> and if the conventional
<code>"definitions"</code> is used then a shorter <code>moo.schema.ref("target")</code> may be
used.
</p>

<p>
In either case, it is required for the Jsonnet developer to assure
that <code>&lt;path&gt;</code> is included in the output.  The conventional
<code>"definitions"</code> may be provided to <code>moo.schema.schema()</code> as an
argument.
</p>

<p>
Unless a recursive data structure is required, or the Jsonnet
structure requires prohibitively long times to compile, it is
recommended to avoid JSON Schema referencing and rely on Jsonnet
referencing.
</p>
</div>
</div>

<div id="outline-container-selection" class="outline-3">
<h3 id="selection">Selection</h3>
<div class="outline-text-3" id="text-selection">
<p>
Schema is described in a nested way with schema being composed of more
schema (it's schemas all the way down).  It will often be the case
that a model or a template or both require a schema which is embedded
in a larger schema.  <b>moo</b> allows selecting sub-schema in two ways:
through Jsonnet and on the command line.
</p>
</div>

<div id="outline-container-jsonnet-selection" class="outline-4">
<h4 id="jsonnet-selection">Jsonnet selection</h4>
<div class="outline-text-4" id="text-jsonnet-selection">
<p>
Jsonnet provides selection in the same way as composition, that is
through references.  One may construct a large schema in one Jsonnet
file and write a second Jsonnet file which imports the first and
exposes the desired subset.  The first may be written to assist in
this selection.  For example, if the main schema has:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> defs = {
    broker: { ... },
};
{
    defs:: defs,
    schema : moo.schema.schema(...)
}
</pre>
</div>

<p>
Then this Jsonnet file can evaluate to just the broker:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> main = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"schema.jsonnet"</span>;
main.defs.broker
</pre>
</div>
</div>
</div>

<div id="outline-container-cli-selection" class="outline-4">
<h4 id="cli-selection">Command line selection</h4>
<div class="outline-text-4" id="text-cli-selection">
<p>
The <code>moo</code> command line provides a way to reference into schema (and
model) structure.  For example, the schema that governs the <code>url</code>
property of the top-level "hello" schema can be selected out during
compilation:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P properties.url hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
}
</pre>
</div>

<p>
The <code>moo</code> command also provides a way to simultaneously select a schema
path and a model path.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -D name -S properties.name -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
Again, lack of any error shows a successful validation.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Viren</p>
<p class="date">Created: 2020-05-28 Thu 14:38</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
