<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-27 Wed 13:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>moo 無</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Brett Viren" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/darksun.css"/>
<link rel="stylesheet" type="text/css" href="export/styles/darksun/css/hideshow.css"/>
<script type="text/javascript" src="export/styles/darksun/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/darksun.js"></script>
<script type="text/javascript" src="export/styles/darksun/js/hideshow.js"></script>
<script type="text/javascript" src="export/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">moo 無
<br />
<span class="subtitle">Model Oriented Objects</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#intro">Introduction</a>
<ul>
<li><a href="#quickstart">Quick start</a></li>
<li><a href="#hello-codgen">Hello codegen</a>
<ul>
<li><a href="#hello-model">Hello model</a></li>
<li><a href="#org956c2d7">Hello template</a></li>
<li><a href="#hello-schema">Hello schema</a></li>
<li><a href="#hello-building">Hello build</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#going-forward">A codec</a>
<ul>
<li><a href="#schema">Schema</a>
<ul>
<li><a href="#codec-schema">Codec schema</a></li>
</ul>
</li>
<li><a href="#models">Models</a></li>
<li><a href="#templates">Templates</a></li>
</ul>
</li>
<li><a href="#command">Command</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#build">Build</a></li>
<li><a href="#org154c6dd">Other</a>
<ul>
<li><a href="#composition">Composition</a></li>
<li><a href="#selection">Selection</a>
<ul>
<li><a href="#jsonnet-selection">Jsonnet selection</a></li>
<li><a href="#cli-selection">Command line selection</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-intro" class="outline-2">
<h2 id="intro">Introduction</h2>
<div class="outline-text-2" id="text-intro">
<p>
Model-oriented objects (moo) generates code by applying a code
<i>template</i> to a data structure (the model).  
</p>

<div class="org-center">
<p>
\(moo(M, T) \to C\)
</p>
</div>

<p>
This is an age old idea and moo is particularly influenced by the code
generator <a href="https://github.com/zeromq/gsl">gsl</a> as it is applied to <a href="https://github.com/zeromq/zproto">zproto</a>/<a href="https://github.com/zeromq/zproject">zproject</a> templates by the
ZeroMQ community.
</p>

<p>
moo provides a general basis for generation.  Some example of its
application include modeling and generating native language data
structures, their serialization methods, RPC or other protocol message
and endpoint behaviors (finite state machines), application and system
wide configuration methods and their configuration objects,
documentation, architectural and design diagrams and even artwork.
</p>

<p>
moo consists of these main aspects:
</p>

<ul class="org-ul">
<li>A moo <b>model</b> is a data structure such as one might represent in JSON,
YAML or in Python with <code>dict</code> and <code>list</code> objects and fundamental string
and numeric types.  With moo you may define a model in many
languages (JSON, XML, YAML and various others) and moo provides
explicit support for using the <a href="https://jsonnet.org">Jsonnet</a> data language.  See the
section <a href="#models">Models</a> for details.</li>

<li>A moo <b>template</b> is a file written primarily in whatever target code
language (C++, Python, LaTeX, GraphViz dot, SQL, HTML, etc) which
has <a href="https://jinja.palletsprojects.com">Jinja2</a> template markup added.  Details are found in <a href="#templates">Templates</a>.</li>

<li>Developers of models and templates should form a contract by
producing a <b>schema</b>.  A model may then be validated against the
schema to assure it provides a structure expected by the template.
Some models themselves provide elements which are schema (eg,
modeling a message type).  These models may include schema
structure.  Schema data structures may be written in the same
variety of languages as may models and moo provides support for
Jsonnet.  In moo a schema data structure must be expressed as <a href="http://json-schema.org/">JSON
Schema</a> (regardless of the language).  moo includes a JSON Schema
that validates JSON Schema and it may be used in user schema to
validate models that include parts which are written as JSON Schema
forms.  See the section <a href="#schema">Schema</a> for more information.</li>

<li>The <code>moo</code> Python module provides methods to handle all of the actions
involved in the codegen including compiling of Jsonnet to JSON,
reading Jsonnet, JSON, XML, YAML, etc into memory-resident data
structures, validating those structures and finally applying them to
a template to generate code.  See <a href="#python">Python</a>.</li>

<li>The <code>moo</code> program exposes the same functionality to the command line
and is described more in <a href="#command">Command</a>.</li>

<li>A <a href="https://waf.io">Waf</a> build system example is provided which demonstrates how to
generate the tasks to generate code.  See <a href="#build">Build</a>.</li>
</ul>

<p>
The remainder of this introduction provides a quick-start guide to
install the moo package and then walks through a simple "Hello
codegen!" example.  Remaining sections cover each main aspect listed above
</p>
</div>

<div id="outline-container-quickstart" class="outline-3">
<h3 id="quickstart">Quick start</h3>
<div class="outline-text-3" id="text-quickstart">
<ul class="org-ul">
<li>install</li>
<li>build</li>
<li><code>moo --help</code></li>
</ul>
</div>
</div>

<div id="outline-container-hello-codgen" class="outline-3">
<h3 id="hello-codgen">Hello codegen</h3>
<div class="outline-text-3" id="text-hello-codgen">
<p>
In this example we develop a trivial schema, a model that adheres to
the schema and a template that accepts schema-valid models.  We defer
any explanation until later sections.
</p>
</div>

<div id="outline-container-hello-model" class="outline-4">
<h4 id="hello-model">Hello model</h4>
<div class="outline-text-4" id="text-hello-model">
<p>
Our first "hello" model is very simple.  
</p>

<div class="org-src-container">
<pre class="src src-jsonnet">{
    name: <span style="color: #e9b96e;">"moo home page"</span>,
    url : <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>,
}
</pre>
</div>

<p>
This example is simple that the use of Jsonnet rather than base JSON
hardly seems useful.  However, for anyone that has ever had to write
raw JSON, simply being able to drop quotes around keys and leave in a
final comma makes Jsonnet so much more human friendly.
</p>

<p>
As our models grown in complexity we will see how Jsonnet becomes even
more useful and how moo provides some additional help.
</p>

<p>
We can generate JSON:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"name"</span>: <span style="color: #e9b96e;">"moo home page"</span>,
    <span style="color: #b4fa70;">"url"</span>: <span style="color: #e9b96e;">"https://brettviren.github.io/moo"</span>
}
</pre>
</div>

<p>
That's it.  That's our boring object.  Next, let's put it to use.
</p>
</div>
</div>

<div id="outline-container-org956c2d7" class="outline-4">
<h4 id="org956c2d7">Hello template</h4>
<div class="outline-text-4" id="text-org956c2d7">
<p>
It is the template where all an abstract rubber model finally meets
the road.  We may write many types of templates that all accept many
models which adhere to a particular schema (see <a href="#hello-schema">Hello schema</a> next).
Here we show two.
</p>

<p>
First is a simple web page which interprets the model as an HTML link.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
&lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">"{{url}}"</span>&gt;{{name}}&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo generate hello/model_hp.jsonnet hello/link.html.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #fce94f;">html</span>&gt;
&lt;<span style="color: #fce94f;">a</span> <span style="color: #fcaf3e;">href</span>=<span style="color: #e9b96e;">""</span>&gt;&lt;/<span style="color: #fce94f;">a</span>&gt;
&lt;/<span style="color: #fce94f;">html</span>&gt;
</pre>
</div>

<p>
The second is a simple command line tool that bakes in specific
targets for download.
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading {{name}}"</span>
wget -O <span style="color: #e9b96e;">"{{name}}"</span> <span style="color: #e9b96e;">"{{url}}"</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo generate hello/model_hp.jsonnet hello/downloader.sh.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-shell"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">bash</span>
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"Downloading "</span>
wget -O <span style="color: #e9b96e;">""</span> <span style="color: #e9b96e;">""</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-hello-schema" class="outline-4">
<h4 id="hello-schema">Hello schema</h4>
<div class="outline-text-4" id="text-hello-schema">
<p>
In moo, schema is strictly optional but recommended.  It used to
specify how a compliant model may be structured in order to form a
contract between model and template developers.
</p>

<p>
Here is our "hello" schema which may validate our "hello" model:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ms = moo.schema;
<span style="color: #b4fa70;">local</span> top = ms.schema(ms.object({
    name:ms.string(),
    url:ms.string(format=<span style="color: #e9b96e;">"uri"</span>)
}, required=[<span style="color: #e9b96e;">"name"</span>, <span style="color: #e9b96e;">"url"</span>]));
std.prune(top)
</pre>
</div>

<p>
We start to see some non-trivial Jsonnet and some support moo provides
for writing schema.  A tutorial on Jsonnet won't be included here
instead we point the interested reader to the well written <a href="https://jsonnet.org/learning/tutorial.html">Jsonnet
tutorial</a> and <a href="https://jsonnet.org/ref/stdlib.html">standard library reference</a>.  But, one thing to take note
of is the first line:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
</pre>
</div>

<p>
This <code>moo.jsonnet</code> module provides all of moo's extra support for
Jsonnet.  For most schema and models developed in Jsonnet it will be
helpful to use.  It is found in the <code>moo</code> Python package directory and
is located automatically by the <code>moo</code> command line program.
</p>

<p>
We may compile this "hello" schema Jsonnet file using the C++ or Go
command line programs but the <code>moo</code> command is provided and brings some
additional convenience.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"$schema"</span>: <span style="color: #e9b96e;">"http://json-schema.org/draft-07/schema#"</span>,
    <span style="color: #b4fa70;">"properties"</span>: {
        <span style="color: #b4fa70;">"name"</span>: {
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        },
        <span style="color: #b4fa70;">"url"</span>: {
            <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
            <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
        }
    },
    <span style="color: #b4fa70;">"required"</span>: [
        <span style="color: #e9b96e;">"name"</span>,
        <span style="color: #e9b96e;">"url"</span>
    ],
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"object"</span>
}
</pre>
</div>

<p>
This "hello" schema will accept a model as valid if it has two
attributes: <code>name</code> which has a value of string and <code>url</code> which is also a
string following a particular format.  This is JSON Schema language
and to learn this simple language, see <a href="http://json-schema.org/understanding-json-schema/">Understanding JSON Schema</a>.
</p>

<p>
We may use the <code>moo</code> command line program to perform validation of the
model against the schema.  It relies on the Python package <a href="https://python-jsonschema.readthedocs.io">jsonschema</a>
for the heavy lifting and its coverage of JSON Schema specification.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
The lack of any error here indicates validity.  We can disturb the
model by removing a required attribute key or providing a value of the
wrong type.  For example, let us change the <code>url</code> attribute value to
hold the integer <code>42</code>.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> hello = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"model_hp.jsonnet"</span>;
hello { url : 42 }
</pre>
</div>

<p>
Note, this uses a Jsonnet language feature to reuse first model and
override just its <code>url</code> attribute with a new one.  If the first model
changes in orthogonal ways, this derived model need not.  In any case,
we can now determine that new model is no longer valid against the
schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -s hello/schema.jsonnet hello/model_hp_invalid.jsonnet 2&gt;&amp;1 |tail -7
</pre>
</div>

<pre class="example">
jsonschema.exceptions.ValidationError: 42 is not of type 'string'

Failed validating 'type' in schema['properties']['url']:
    {'format': 'uri', 'type': 'string'}

On instance['url']:
    42
</pre>
</div>
</div>

<div id="outline-container-hello-building" class="outline-4">
<h4 id="hello-building">Hello build</h4>
<div class="outline-text-4" id="text-hello-building">
<p>
This example is simple enough that command line invocations are
sufficient.  As our system of schema, models and templates grow, a
layer of automated task generation becomes rather welcome.  moo
provides a Waf-based example of that.  The main <a href="wscript">wscript</a> file may be
used as a starting point and our "hello" example provides a
<a href="hello/wscript_build">wscript<sub>build</sub></a> file showing how one may extend the main wscript to
handle domain-specific codegen.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #73d216;"># </span><span style="color: #73d216;">of course this itself should be generated....</span>

bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_link.html"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"link.html.j2"</span>))
bld(source=<span style="color: #e9b96e;">"model_hp.jsonnet"</span>, target=<span style="color: #e9b96e;">"hello_downloader.sh"</span>,
    template=bld.path.find_resource(<span style="color: #e9b96e;">"downloader.sh.j2"</span>))
</pre>
</div>

<p>
And build:
</p>
<pre class="example">
$ waf configure
$ waf
$ ls build/hello_*
</pre>

<p>
This build is fairly simple and so each target is exhaustively listed.
As the number of targets grow we may exploit symmetries to codify the
Waf task generation.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-going-forward" class="outline-2">
<h2 id="going-forward">A codec</h2>
<div class="outline-text-2" id="text-going-forward">
<p>
This section uses moo to develop an extended example to show more of
what may be accomplished with moo.  The goal will be to generate code
which implements a <i>codec</i>.  Here, a codec means software that can
serialize a data structure that is represented by native language
types into a series of bytes (encode) and from a properly encoded
series of bytes reproduce the structure (decode).  One way to
illustrate a codec is shown in the following diagram:
</p>


<div class="figure">
<p><object type="image/svg+xml" data="./codec.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
The <i>recv</i> represents a source of encoded data or <i>messages</i> and likewise
the <i>send</i> is a sink.  We will allow different <i>types</i> of encoded messages
to map differently to the data structure of the codec. In the diagram
the data structure is represented by the <i>fields</i> node.  The <i>id</i> is a
special field made explicit and is used to represent the message type
or the mapping from encoding to structure.  The <i>setters</i> and <i>getters</i>
represent field accessor methods such as may be used by an application
to modify or query the current value held in the codec.
</p>

<p>
Given multiple message types, possibly sharing semantically identical
fields, there are two extremes how to represent the data structure
managed by the codec.
</p>

<p>
The first one is to present the <i>fields</i> as a flat set of attributes
where only those attributes which are mapped to the current <i>id</i> are
considered valid for calling.  The codec API then provides one <i>getter</i>
and one <i>setter</i> method for the union of fields across all supported
messages.
</p>

<p>
The other extreme is to maintain strict one-to-one mapping between
message type and a native language type (typically a <code>struct</code> or <code>class</code>).
The codec API then provides one <i>getter</i> and one <i>setter</i> for each message
type which allows atomic access to the corresponding native language
type.
</p>

<p>
The general development parts include: 
</p>

<dl class="org-dl">
<dt>schema</dt><dd>we will expect our models to describe messages types in terms of an <i>id</i> of type string and a <i>body</i> which is specified as a schema.</dd>

<dt>model</dt><dd>our model describe message types such as may be used in a simple control, configure and monitor (CCM) system</dd>

<dt>templates</dt><dd>we will make templates to define C++ types corresponding to each message, C++ functions to serialize them using at least two methods (JSON and MessagePack), test code, documentation, etc.</dd>
</dl>
</div>

<div id="outline-container-schema" class="outline-3">
<h3 id="schema">Schema</h3>
<div class="outline-text-3" id="text-schema">
<p>
In moo, schema plays a central role and we need to describe a bit
before diving in.  
</p>

<p>
The primary purpose of a schema document in moo is to provide a
<i>contract</i> between model and template developers.  We wish to write
\(N_M\) models which may be applied to \(N_T\) templates.  Without such a
contract, we must validate by applying each template to each model and
look for failures.  This is a \(N_M \times N_T\) process.  By
insinuating a contract in the form of a schema it becomes a \(N_M +
N_T\) process.
</p>

<p>
The second use of schema is that sometimes our models need to describe
"types of things" and that is precisely what a schema does.  An
immediate example will include the codec message types.  Instead of
inventing a new way for models to express schema separate from the
schema used to validate models, moo uses the same schema language for
both purposes, JSON Schema.
</p>

<p>
This may sound convoluted and recursive, and it is.  However, there is
a schema written in JSON Schema which validates any schema written in
JSON Schema (including itself).  Thus we can include JSON Schema in
our schema and in our models.  
</p>

<p>
With moo we may provide data structures represented in many languages.
Any language format supported by the <code>anyconfig</code> Python module or any
language that may produce such formats may be used.  In particular,
moo provides support for creating data structures for moo using
Jsonnet.  The reason why such variety can be supported by moo is that
schema validation, application of model to template and other
operations all occur on data structures in memory.  Populating those
structures from a particular persistent representation is factored out
and parameterized by the format.  This may be extended in the future
to support data structures loaded from SQL or noSQL type stores.
</p>

<p>
Thus, to develop your own schema data structures with moo's Jsonnet,
first spend some quality time with <a href="http://json-schema.org/understanding-json-schema/">Understanding JSON Schema</a>.  This
document provides a fast and excellent learning resource to understand
JSON Schema.  A large, if not complete, fraction of JSON Schema is
reflected into <code>moo.schema</code> functions so as you learn JSON Schema focus
on structure not on syntax and you may then map JSON Schema keywords
into moo Jsonnet functions.  
</p>

<p>
As we will see used next, moo Jsonnet also provides additional schema
to more exactly specify types including attributes for numeric sizes,
formats, units.
</p>
</div>

<div id="outline-container-codec-schema" class="outline-4">
<h4 id="codec-schema">Codec schema</h4>
<div class="outline-text-4" id="text-codec-schema">
<p>
Here is an outline of a schema which broadly specifies a codec for the
purpose of this example:
</p>

<ul class="org-ul">
<li>A codec has some number of message types and each type has an attribute:</li>
<li><code>ident</code> giving a unique message type identifier and</li>
<li><code>body</code> which holds schema describing the structure of the message payload.</li>
</ul>

<p>
Based on such a schema, a number of models are developed each of which
a number of message types and each of those which provides an <code>ident</code>
value and a <code>body</code> schema.  And, with the schema in hand, a variety of
templates are developed which may generate code given any one of these
models.
</p>

<p>
In practice, a codec typically goes further to specify in detail how
every bit of schema maps to a byte stream.  We will leave this as an
implementation detail left to a <i>serialization</i> method chosen by the
template.  This means that we do not expect to convert an data object
produced by code generated from one model/template pair to necessarily
be compatible with code generated from the same model but a different
template.  Instead, we will need to organize templates into compatible
categories.  For example, one template may produce C++ native types
structure which may be shared by a variety of templates producing
individual serialization methods.  An application must take care to
match both ends of a data stream with matching serialization but may
use the same model.  OTOH, we may also produce Python native types
which are compatible with C++ native types when joined by suitably
matching Python and C++ ends of serialization methods.
</p>

<p>
In any case, in a formal moo Jsonnet schema the codec schema can be
defined as:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> moo = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"moo.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ms = moo.schema;
<span style="color: #b4fa70;">local</span> mt = moo.types;
{
    ident: ms.string(),
    body: ms.jsonschema(),
    mtype: ms.object({ident:$.ident,body:$.body}, [<span style="color: #e9b96e;">"ident"</span>]),
    codec: ms.array($.mtype),

    schema : std.prune($.codec),

    types :: mt + {
        timestamp: { issued: mt.timestamp(<span style="color: #e9b96e;">"i8"</span>, <span style="color: #e9b96e;">"ms"</span>)},
        mtype(name,body):: {ident:name, body:body },
    }
}
</pre>
</div>

<p>
We expose sub-schema (eg <code>mtype</code>) so that this schema may be easily
reused in other, larger schema.  We take the convention that the
"final result" schema for this file is found as the keyword <code>schema</code>.  
</p>

<p>
The <code>body</code> keyword is set to the output of <code>moo.schema.jsonschema()</code>.
This says that any valid model may provide a value for a <code>body</code> keyword
which is itself some form of valid JSON Schema.  This is a rather
open-ended contract which still puts a burden on template developers
to implement any valid JSON Schema structure.  With that challenge
overcome, one may then have a fully generic (up to requiring the
<code>ident</code>) system.  We can lighten the burden by applying more
"opinionated" schema for <code>body</code>.  For example, we may limit the <code>body</code> to
specify it as a "flat" object with its attributes only consisting of
scalar strings and numbers.  For this codec example, we will "cheat"
and say that the models and the templates will share an unspecified
sub-contract which keep structure simple in hopes that some future
development brings wealth of full generality.
</p>

<p>
Another detail to note is the use of <code>std.prune()</code> in defining the final
schema.  This reduction removes any <code>null</code> entries that may arise.  For
example, a <code>string()</code> takes an optional <code>format</code> argument which defaults
to <code>null</code>.  We can bury this inside each Jsonnet schema function but its
repeated call tends to degrade performance compared to a one-time
traversal of the final data structure.
</p>

<p>
To drop down one level of meta, here is the codec schema compiled to
JSON Schema:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P schema codec/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"items"</span>: {
        <span style="color: #b4fa70;">"properties"</span>: {
            <span style="color: #b4fa70;">"body"</span>: {
                <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"https://json-schema.org/draft-07/schema"</span>
            },
            <span style="color: #b4fa70;">"ident"</span>: {
                <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
            }
        },
        <span style="color: #b4fa70;">"required"</span>: [
            <span style="color: #e9b96e;">"ident"</span>
        ],
        <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"object"</span>
    },
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"array"</span>
}
</pre>
</div>


<p>
Note how JSON Schema '$ref' keyword is used to refer to schema held
externally to avoid having to copy its contents.  
</p>

<p>
We may also validate this schema with the <code>moo validate</code> command.  In
general this command takes a <code>-s/--schema</code> option to set the schema
against which we validate the argument (eg a file holding a model).
Here, our schema file is the argument and we rely on the default
validation schema to be JSON Schema itself, represented <b>as</b> JSON
Schema, no less and just as we see used in the <code>body</code> attribute.  We see
the convoluted recursion in full force here, but in the end it all
works:.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate codec/schema.jsonnet
</pre>
</div>

<pre class="example">

</pre>

<p>
No news is good news.
</p>
</div>
</div>
</div>


<div id="outline-container-models" class="outline-3">
<h3 id="models">Models</h3>
<div class="outline-text-3" id="text-models">
<p>
In moo, a model is a data structure which describes some abstract
"thing" (object) with the goal that it may be applied to one or more
templates in order to generate code.  A model should adhere to (be
validated by) a schema as just discussed.
</p>

<p>
Just as with a schema, a developer may define a model in many data
languages.  moo supports models written in JSON, XML, YAML, and
various others (anything supported by the <code>anyconfig</code> Python module).
And of course developers are free to develop models in any form that
may generate these formats.  What ultimately matters is the in-memory
model data structure.
</p>

<p>
That variety aside, moo provides special support for defining models
in Jsonnet.  In particular, it provides functions to help create a
model in ways that assure consistent forms across models and in ways
that tend to produce models which are, by construction, valid against
schema.
</p>

<p>
In a properly constructed moo <code>schema.jsonnet</code> file, these functions are
available under the <code>.types</code> attribute.  It should extend the <code>.types</code>
structure from any inherited schema starting with what is provided by
<code>moo.jsonnet</code>.  Unlike the structure under <code>.schema</code>, the structure
provided by <code>.types</code> functions is assertive and not used for validation.
</p>

<p>
In this section will develop a model for the CCM codec example
described above.
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> codec = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"codec/schema.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ct = codec.types;

<span style="color: #73d216;">// This model wants every message type to carry some common fields</span>
<span style="color: #b4fa70;">local</span> mtype(ident, payload={}) = ct.mtype(ident, ct.timestamp + payload);

std.prune([
    mtype(<span style="color: #e9b96e;">"config"</span>, {role:ct.str(), cfgid: ct.str()}),
    mtype(<span style="color: #e9b96e;">"start"</span>),
    mtype(<span style="color: #e9b96e;">"stop"</span>),
    mtype(<span style="color: #e9b96e;">"log"</span>, {level: ct.str(), message: ct.str()}),
])
</pre>
</div>

<p>
Consider the <code>"config"</code> message type which we can show as JSON Schema
like:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P 0 ccm/model.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"body"</span>: {
        <span style="color: #b4fa70;">"cfgid"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"issued"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b2e3;">0</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"i8"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"num"</span>,
            <span style="color: #b4fa70;">"unit"</span>: <span style="color: #e9b96e;">"ms"</span>
        },
        <span style="color: #b4fa70;">"role"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        }
    },
    <span style="color: #b4fa70;">"ident"</span>: <span style="color: #e9b96e;">"config"</span>
}
</pre>
</div>

<p>
Real systems will have many entities to configure.  Considering the
system from a top-down view, we may define a number of abstract
"roles" that the entities enact and we will specify some portion of a
configuration object schema to be supported by a role.  With bottom-up
consideration we know that each implementation of any given entity
will need specific configuration parameters and thus also contribute
to the specification of configuration structure.
</p>

<p>
In this example we leave that "subclassing" to some external entity
which is resolved by the <code>"cfgid"</code>.  Its value is perhaps used by the
entity as a key to look up a full configuration in some database.  
</p>

<p>
With more effort now, we may instead handle this complexity directly
in our model.  We could remove <code>"cfgid"</code> and instead model a <code>"config"</code>
like message type for every implementation.  If the role-level
configuration is substantial, we'd like to factor it out or derive
from this base model to produce a per-implementation config.  
</p>

<p>
We show this latter technique with this contrived example:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> codec = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"codec/schema.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> ct = codec.types;
<span style="color: #b4fa70;">local</span> parent = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"model.jsonnet"</span>;
<span style="color: #b4fa70;">local</span> cfg = parent[0];

cfg {
    body: <span style="color: #b4fa70;">super</span>.body {
        favorite_color: ct.str(def=<span style="color: #e9b96e;">"purple"</span>),
    }
}
</pre>
</div>
<div class="org-src-container">
<pre class="src src-shell">moo compile ccm/server.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"body"</span>: {
        <span style="color: #b4fa70;">"cfgid"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"favorite_color"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">"purple"</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        },
        <span style="color: #b4fa70;">"issued"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b2e3;">0</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"i8"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"num"</span>,
            <span style="color: #b4fa70;">"unit"</span>: <span style="color: #e9b96e;">"ms"</span>
        },
        <span style="color: #b4fa70;">"role"</span>: {
            <span style="color: #b4fa70;">"def"</span>: <span style="color: #e9b96e;">""</span>,
            <span style="color: #b4fa70;">"dtype"</span>: <span style="color: #e9b96e;">"&lt;U"</span>,
            <span style="color: #b4fa70;">"mootype"</span>: <span style="color: #e9b96e;">"str"</span>
        }
    },
    <span style="color: #b4fa70;">"ident"</span>: <span style="color: #e9b96e;">"config"</span>
}
</pre>
</div>

<p>
The same template that can consume each of the message type models in
<code>ccm/model.jsonnet</code> will be able to consume this contrived specialized
implantation called "server".
</p>
</div>
</div>


<div id="outline-container-templates" class="outline-3">
<h3 id="templates">Templates</h3>
<div class="outline-text-3" id="text-templates">
<p>
In moo, templates are files written in some target language with
Jinja2 markup interspersed.  A template applied to a model to generate
code in that target language.  The template is developed with the
model's schema in mind.
</p>

<p>
This section extends the CCM codec example.  The first template to
illustrate is one that generates a native language C++ type for a
model of a message type.
</p>

<div class="org-src-container">
<pre class="src src-c++">{%- macro defval(p) -%}
{% <span style="color: #b4fa70;">if</span> p.mootype == <span style="color: #e9b96e;">"str"</span> %}<span style="color: #e9b96e;">"{{ p.def }}"</span>{% <span style="color: #b4fa70;">else</span> %}{{ p.def }}{% endif %}
{%- endmacro -%}
<span style="color: #73d216;">// </span><span style="color: #73d216;">The message type {{ident}}</span>
<span style="color: #e090d7;">#if</span><span style="color: #e090d7;">n</span><span style="color: #e090d7;">def</span> {{model.ident|upper}}
<span style="color: #e090d7;">#define</span> {{model.ident|upper}}

<span style="color: #b4fa70;">struct</span> {{model.ident}} {
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">ident</span> = <span style="color: #e9b96e;">"{{model.ident}}"</span>;
    {% <span style="color: #b4fa70;">for</span> n,p <span style="color: #8cc4ff;">in</span> <span style="color: #fcaf3e;">model</span>.body.items() %}
    {{ moo.lang.cpp[p.mootype][p.dtype] }} {{ n }} = {{ defval(p) }};
    {% endfor %}
};
<span style="color: #e090d7;">#endif</span> <span style="color: #73d216;">// </span><span style="color: #73d216;">{{ident|upper}}</span>
</pre>
</div>


<p>
And, when we apply the first <code>"config"</code> message type model by selecting
the zeroth element of the full model:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo generate -P 0 ccm/model.jsonnet codec/mtype-first-try.hpp.j2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">The message type </span>
<span style="color: #e090d7;">#if</span><span style="color: #e090d7;">n</span><span style="color: #e090d7;">def</span> CONFIG
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">CONFIG</span>

<span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">config</span> {
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">ident</span> = <span style="color: #e9b96e;">"config"</span>;
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">cfgid</span> = <span style="color: #e9b96e;">""</span>;
    <span style="color: #8cc4ff;">int64_t</span> <span style="color: #fcaf3e;">issued</span> = 0;
    <span style="color: #e9b2e3;">std</span>::<span style="color: #8cc4ff;">string</span> <span style="color: #fcaf3e;">role</span> = <span style="color: #e9b96e;">""</span>;
};
<span style="color: #e090d7;">#endif</span> <span style="color: #73d216;">// </span>
</pre>
</div>

<p>
Now, as the template file name indicates, this represents a first try
and there are many things that make it clearly inadequate.  In
particular, we would like a way to give a C++ namespace and maybe some
hint at what C++ header file this might live in so that we may include
that in the header guards.
</p>
</div>
</div>
</div>

<div id="outline-container-command" class="outline-2">
<h2 id="command">Command</h2>
<div class="outline-text-2" id="text-command">
</div>
</div>


<div id="outline-container-python" class="outline-2">
<h2 id="python">Python</h2>
<div class="outline-text-2" id="text-python">
</div>
</div>


<div id="outline-container-build" class="outline-2">
<h2 id="build">Build</h2>
<div class="outline-text-2" id="text-build">
</div>
</div>

<div id="outline-container-org154c6dd" class="outline-2">
<h2 id="org154c6dd">Other</h2>
<div class="outline-text-2" id="text-org154c6dd">
</div>
<div id="outline-container-composition" class="outline-3">
<h3 id="composition">Composition</h3>
<div class="outline-text-3" id="text-composition">
<p>
Both Jsonnet and JSON Schema have their own forms to <i>compose</i> structure
through <i>references</i>.  This allows defining structure in one place and
using it in multiple places.  Jsonnet references are resolved during
compilation while JSON Schema references are purely logical and
resolved by some interpreter (in case of moo, that's the <code>jsonschema</code>
Python module).  There are a number of trade-offs in selecting how to
employ references.
</p>

<p>
Jsonnet provides these idioms for composing structure with references:
</p>

<ul class="org-ul">
<li>an object produced by one file may be referenced in another via <code>import</code>.</li>
<li>an object may be defined in a <code>local</code> variable and used multiple times within that file.</li>
<li>structure produced by a file may be referenced within the structure with <code>self</code> or <code>super</code> keywords and <code>$.</code> paths.</li>
</ul>

<p>
The benefit of using Jsonnet references is that they are first class
elements of the Jsonnet language.  This means the Jsonnet compiler
will find mistakes.
</p>

<p>
A potential drawback is that the Jsonnet compiler resolves references
by replacing them in the output with a copy of what they reference.
When the same structure is referenced multiple times it leads to
duplication in the output.  Since no human need process the output
this (perfect) redundancy in the output typically does not lead to any
problems.  In some cases when the Jsonnet is very large and there are
costly Jsonnet function calls repeated in the structure, the
compilation time may be noticeably or even prohibitively slower.
</p>

<p>
There is one hard limitation in Jsonnet references and that is that
they must not be used to form a recursive data structure.  This will
lead to compilation errors (stack overflow).
</p>

<p>
With a much different syntax, JSON Schema references are provided
through a <i>special form</i> in the JSON:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"&lt;path&gt;"</span> }
</pre>
</div>

<p>
This entire special form, including the <code>{}</code>'s, is replaced by the value
associated to the attribute found at <code>"&lt;path&gt;"</code> somewhere in the rest of
the JSON.  By convention, a <code>"&lt;path&gt;"</code> is expected to references an
attribute under a top level <code>"definitions"</code> attribute.  For example:
</p>

<div class="org-src-container">
<pre class="src src-json">{ <span style="color: #b4fa70;">"$ref"</span>: <span style="color: #e9b96e;">"#/definitions/target"</span> }
</pre>
</div>

<p>
would be replaced by <code>&lt;content&gt;</code> as found at:
</p>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"definitions"</span> : {
        <span style="color: #b4fa70;">"target"</span> : &lt;content&gt;
    }
}
</pre>
</div>

<p>
JSON Schema also provides way to define a target with an <code>$id</code> attribute
but this feature is currently unsupported by the Python module
<code>jsonschema</code> which moo relies on and we will discard it from
consideration.
</p>

<p>
In Jsonnet, the JSON Schema special form <code>{ "$ref" : "&lt;path&gt;" }</code> may be
created using a call to <code>moo.schema.ref(&lt;path&gt;)</code> and if the conventional
<code>"definitions"</code> is used then a shorter <code>moo.schema.ref("target")</code> may be
used.
</p>

<p>
In either case, it is required for the Jsonnet developer to assure that
<code>&lt;path&gt;</code> is included in the output.  The conventional <code>"definitions"</code> may be provided to <code>moo.schema.schema()</code> as an argument.
</p>

<p>
Unless a recursive data structure is required, or the Jsonnet
structure requires prohibitively long times to compile, it is
recommended to avoid JSON Schema referencing and rely on Jsonnet
referencing.
</p>
</div>
</div>

<div id="outline-container-selection" class="outline-3">
<h3 id="selection">Selection</h3>
<div class="outline-text-3" id="text-selection">
<p>
Schema is described in a nested way with schema being composed of more
schema (it's schemas all the way down).  It will often be the case
that a model or a template or both require a schema which is embedded
in a larger schema.  moo allows selecting sub-schema in two ways:
through Jsonnet and on the command line.
</p>
</div>

<div id="outline-container-jsonnet-selection" class="outline-4">
<h4 id="jsonnet-selection">Jsonnet selection</h4>
<div class="outline-text-4" id="text-jsonnet-selection">
<p>
Jsonnet provides selection in the same way as composition, that is
through references.  One may construct a large schema in one Jsonnet
file and write a second Jsonnet file which imports the first and
exposes the desired subset.  The first may be written to assist in
this selection.  For example, if the main schema has:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> defs = {
    broker: { ... },
};
{
    defs:: defs,
    schema : moo.schema.schema(...)
}
</pre>
</div>

<p>
Then this Jsonnet file can evaluate to just the broker:
</p>

<div class="org-src-container">
<pre class="src src-jsonnet"><span style="color: #b4fa70;">local</span> main = <span style="color: #b4fa70;">import</span> <span style="color: #e9b96e;">"schema.jsonnet"</span>;
main.defs.broker
</pre>
</div>
</div>
</div>

<div id="outline-container-cli-selection" class="outline-4">
<h4 id="cli-selection">Command line selection</h4>
<div class="outline-text-4" id="text-cli-selection">
<p>
The <code>moo</code> command line provides a way to reference into schema (and
model) structure.  For example, the schema that governs the <code>url</code>
property of the top-level "hello" schema can be selected out during
compilation:
</p>

<div class="org-src-container">
<pre class="src src-shell">moo compile -P properties.url hello/schema.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">{
    <span style="color: #b4fa70;">"format"</span>: <span style="color: #e9b96e;">"uri"</span>,
    <span style="color: #b4fa70;">"type"</span>: <span style="color: #e9b96e;">"string"</span>
}
</pre>
</div>

<p>
The <code>moo</code> command also provides a way to simultaneously select a schema
path and a model path.
</p>

<div class="org-src-container">
<pre class="src src-shell">moo validate -D name -S properties.name -s hello/schema.jsonnet hello/model_hp.jsonnet
</pre>
</div>

<div class="org-src-container">
<pre class="src src-json">
</pre>
</div>

<p>
Again, lack of any error shows a successful validation.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Brett Viren</p>
<p class="date">Created: 2020-05-27 Wed 13:53</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
