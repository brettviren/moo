#+title: moo
#+AUTHOR:    Brett Viren
#+EMAIL:     (concat "brett.viren" at-sign "gmail.com")
#+DATE:      2020-04-30
#+OPTIONS:   H:4 num:nil toc:2
#+SETUPFILE: setup/theme-readtheorg-local.setup
#+LANGUAGE:  en
#+HTML_HEAD: <style> #content{max-width:1800px;}</style>
#+HTML_HEAD: <style> p{max-width:1800px;}</style>
#+HTML_HEAD: <style> li{max-width:1800px;}</style>
#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="extra.css"/>


* Introduction
  :PROPERTIES:
  :CUSTOM_ID: intro
  :END:

  #+begin_quote
  ruminants on module oriented programming....
  #+end_quote

*moo* provides a system with a goal to make it easy to develop
ZeroMQ-based message passing protocols.  Instead of writing code we
model the code we want by writing code to generate data structures
that describe the code.  We then apply the these data structures to
templates and generate the code.  It sounds complicated but it's
actually rather simple and incredibly powerful.

** Origin
   :PROPERTIES:
   :CUSTOM_ID: origin
   :END:

*moo* walks down the trail originally blazed by ZeroMQ's [[https://github.com/zeromq/zproto][zproto]] but does
so after selecting a different set of languages:

- models :: Jsonnet/JSON (instead of XML)
- template :: Jinja2 (instead of GSL)
- source :: C++ with ~cppzmq~ (instead of C with CZMQ)

The choice of Jsonnet allows us to describe our model with just enough
of a programming language to relive some tedium and to provide
functions that assure the resulting data structure is valid by
construction.

The choice of Jinja2 gives us a more familiar and "modern" template
system.  Jinja2 lacks some of the useful features compared to GSL but
makes up for it in being more approachable with very good
documentation.

Finally, for ZeroMQ parts we use C++ and [[https://github.com/zeromq/cppzmq][cppzmq]] instead of C and CZMQ.
This is mostly out of personal preference for C++ and ~cppzmq~ and
because some other powerful C++ libraries are used by the generated
code ([[https://github.com/nlohmann/json/][nlohmann/json]] and [[https://github.com/boost-experimental/sml][boost-experimental/sml]]).  Some support exists
in *moo* for generating code in other source languages.

** This manual
   :PROPERTIES:
   :CUSTOM_ID: this
   :END:


The rest of this manual walks through installation, how *moo* models
work, *moo* templates and finally a walk through of a real application.

* Installation
  :PROPERTIES:
  :CUSTOM_ID: install
  :END:

  #+begin_quote
Build it and they will come?  More like, come on, build it already!
  #+end_quote

Much of *moo* functionality is provided as Python package.  As such you
can install it in the "usual Python way".  Since there are many let me
just say my current favorite uses [[https://direnv.net/][direnv]]:

#+begin_example
  $ echo 'layout python3' > .envrc
  $ direnv allow .
  $ pip install -e .
#+end_example

*moo* also provides a [[file:wscript][wscript]] file which [[https://waf.io][Waf]] can use to build the
example C++ project using the ~moo~ Python command line program.  

#+begin_example
  $ waf configure build
#+end_example

This ~wscript~ file may be used as a basis for your own package.  Or you
may call *moo* from whatever build system you prefer.

Note, the ~moo~ Python package and command line program simply provide a
convenient bundle of various things.  If you have reason to call
Jsonnet or Jinja2 compilers directly it should be no problem to copy
out the provided Jsonnet support files and battery-included templates.

* Using the ~moo~ program
  :PROPERTIES:
  :CUSTOM_ID: using
  :END:

  #+begin_quote
  Confusion makes the heart grow fonder. - Grandmama, maybe.
  #+end_quote

In this section we'll show how to use ~moo~ without really understanding
anything too deeply.  Let's just roll with it.

The ~moo~ command line program provides these major functions:

- a Jsonnet compiler
- a Jinja2 compiler
- Jsonnet support functions 
- "batteries included" templates

** Compiling Jsonnet Models
   :PROPERTIES:
   :CUSTOM_ID: jsonnet
   :END:

The ~moo~ program uses the ~jsonnet~ Python package to compile Jsonnet to
a Python data structure and dump that out as JSON or apply it to a
Jinja2 template.  We haven't explained what Jsonnet is and we won't
(but see the excellent [[https://jsonnet.org/learning/tutorial.html][Jsonnet tutorial]]).  We'll use an example of a
*moo* model to show it off a bit.  We also haven't really explained what
that a *moo* model is but we will soon.  Since we don't know nothing,
let's take a provided model which we'll meet again.  It is in the
file: [[file:examples/object1.jsonnet][examples/object1.jsonnet]] and included here:

#+include:  examples/object1.jsonnet src jsonnet

And, here is how ~moo~ can compile it to JSON and the result:

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  moo compile examples/object1.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
{
    "attrs": [
        {
            "def": "purple",
            "name": "color",
            "type": {
                "c": "std::string",
                "def": "",
                "j": "string",
                "n": "<U",
                "name": "str",
                "p": "str"
            }
        },
        {
            "def": 0,
            "name": "count",
            "type": {
                "c": "int",
                "def": 0,
                "j": "number",
                "n": "i4",
                "name": "int",
                "p": "int"
            }
        }
    ],
    "help": "A container full of yumminess",
    "name": "candies"
}
#+end_src

Thrilling, isn't it.  And verbose.  You may think, why bother with
Jsonnet, why not just write JSON.  Be my guest, friend.  Those ~type~
objects are particularly glaring.  We'll talk more about them in [[Basic Types]] below.

** Filtering Structure
   :PROPERTIES:
   :CUSTOM_ID: filtstruct
   :END:

There may be cases where only a certain substructure is required to be
applied to a template, or maybe you just want to check out part of a
big complex data structure.  We can ask ~moo~ to select that
substructure and see the result with the ~compile~ command.  Here's the
previous structure with just the first element of ~attrs~ selected:

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  moo compile -p attrs.0 examples/object1.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
{
    "def": "purple",
    "name": "color",
    "type": {
        "c": "std::string",
        "def": "",
        "j": "string",
        "n": "<U",
        "name": "str",
        "p": "str"
    }
}
#+end_src

The "-p" specifies a "dot path" through the structure.  It's obvious what that means, right?

** Locating files

As our library of models (and templates) grows we will likely want to
factor them into different areas.  To help find them, we can set
~JSONNET_PATH~ to find Jsonnet files (and ~JINJA2_PATH~ to find Jinja2
templates) or to use command line options:

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  moo compile -J examples -p help object1.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
"A container full of yumminess"
#+end_src

Note, the options shown above work also for the ~moo generate~ command
described next.

** Generating from templates
   :PROPERTIES:
   :CUSTOM_ID: generating
   :END:

We will "get serious" in the sections below but let's start with a
simple, self contained example of generating source code from a model
and a template.  We do this just to put ~moo~ through its paces.  You'll
see some things that may not make sense, and that's okay, not
everything has to make sense.

First, we write a Jinja2 template file.  Since we don't yet know how
to do that, we take one that we find in [[file:examples/hello-types.hpp.j2][examples/hello-types.hpp.j2]].
It is a contrived example C++ header file template:

#+include: examples/hello-types.hpp.j2 src c++

We still don't know what a model is so let's take that from the can
too.  We will apply the simple model file
[[file:examples/hello-types.jsonnet][examples/hello-types.jsonnet]]:

#+include: examples/hello-types.jsonnet src jsonnet

We compile the template against the model with ~moo~ to generate a final C++
file:

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  moo generate examples/hello-types.jsonnet examples/hello-types.hpp.j2
#+end_src

#+RESULTS:
#+begin_src c++
/* 100% GENERATED FILE DO NOT EDIT
 ,*
 ,* Known types:
 ,* 
 ,*/

#ifndef HELLO_MYTYPE
#define HELLO_MYTYPE

namespace hello {

struct MyType {
    int x = 0;
    std::string s = "";
};

void to_json(json& j, const person& p)
{
    j = json{{"x", p.x},{"s", p.s}};
}

void from_json(const json& j, person& p)
{
    j.at("x").get_to(p.x);
    j.at("s").get_to(p.s);
}
} // namespace hello
#endif
#+end_src

In the spirit of the lack of understanding in this section, don't
worry too much about this even being a valid C++ file.  Maybe it won't
even compile.  We don't care.  Just observe how we have performed a
"convolution" of two text files with ~moo~.  That alone should be reward
enough but if you want more, revel in compiling Jsonnet to JSON to
Python data in order to generate C++ code to convert C++ types to
JSON.


* Model
  :PROPERTIES:
  :CUSTOM_ID: model
  :END:

  #+begin_quote
  Before may we model, must we model how we model. 
  #+end_quote

Mixing data structures and templates is cute but it's no big deal.
The big deal about ~moo~ is capturing expertise and separation of
concerns.  The first concern is salient information will change from
application to application.  In *moo* we call this information "the
model".

Ultimately, our eventual model is a data structure which follows a
particular object schema.  This data structure will eventually
describes all the parts that will, through templates, generate a
software implementation.  As *moo* targets creation of "protocol
endpoints" the schema our model follows is described in term of the
"taxonomy of protocol endpoints".  We don't know what the heck a
"taxonomy of protocol endpoints" is, but that shouldn't stop us from
creating it.

But, first we must say that the data structure which is our model will
be rather annoying to write out in long hand.  Thus we will model our
model in Jsonnet.  So this section is really modeling a model of our
model.  This is of course ridiculous (despite being true).  To keep it
simple, *moo* gives us some Jsonnet functions and data structures to use
when constructing a model that forces the resulting data structure to be
well formed.  In fact, it is these functions that define the schema
which our templates must finally honor.

** Basic Types
   :PROPERTIES:
   :CUSTOM_ID: types
   :END:

As we saw a sneak peak in [[Generating from templates]], eventually our
model will be applied to a template in order to generate code in some
/target programming language/ (eg, C++).  In our model we will avoid
including any target language.  However, we will have the need to
model basic types.  We'll make up our own type names and they are
provided in the [[file:moo/moo/jsonnet/moo.jsonnet][moo.jsonnet]] Jsonnet support library as ~moo.types~.  For
example the ~moo.types.int~ type is this data structure,

#+begin_src shell :exports both :results output code :wrap "SRC c++"
  moo compile -p types.int moo.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
{
    "c": "int",
    "def": 0,
    "j": "number",
    "n": "i4",
    "name": "int",
    "p": "int"
}
#+end_src

It provides C++ (c), Python (p), Numpy dtype (n) and Jsonnet (j) types.  It also provides in the ~name~ the ~moo.types~ key and a default value as ~def~.  You can see all types with:

#+begin_example
  $ moo compile -p types moo.jsonnet
#+end_example

But that's too long to put here so instead, lets just show the type names:

#+begin_src jsonnet
  local moo = import "moo.jsonnet";
  std.objectFields(moo.types)
#+end_src

Which gives:

#+begin_src shell :exports results :results output code :wrap "SRC c++"
  moo compile examples/dumptypes.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
[
    "byte",
    "char",
    "double",
    "float",
    "int",
    "int16",
    "int32",
    "int64",
    "int8",
    "str",
    "uint16",
    "uint32",
    "uint64",
    "uint8",
    "void"
]
#+end_src

Not so exciting, I will grant you.  Just know that when you need to
model a type you should use an attribute of ~moo.types~.

** Attributes
   :PROPERTIES:
   :CUSTOM_ID: attributes
   :END:

We just learned how to name types.  We also established it is pretty
boring.  What's really fun is to name things.  And what's crazy fun is
to name things with types.  If we can handle it we might even name
things with types and suggest a default value!  

A named, typed, valued thing in *moo* is called an ~attribute~ (an
attribute /model/ if we get wordy).  An attribute of what, you ask?  Who
knows?  Well, we do, but we do not yet say.  So, let's just model an
attribute and see how it looks:

#+include: examples/attribute1.jsonnet src jsonnet

Compiling:

#+begin_src shell :exports results :results output code :wrap "SRC c++"
  moo compile examples/attribute1.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
{
    "def": "purple",
    "name": "color",
    "type": {
        "c": "std::string",
        "def": "",
        "j": "string",
        "n": "<U",
        "name": "str",
        "p": "str"
    }
}
#+end_src

So, an ~attribute~ has a ~name~ a ~type~ and a default (~"def"~)
value.  That value is given as a Jsonnet value of the corresponding
Jsonnet type.  In the template, this will translate into a value in
the template language (which will be Python as *moo* uses Jinja2, but
we are getting way ahead of ourselves, so calm down).


Of course, once you have one attribute, you want more.  Well, have all the attributes you want.  Just put them into an array.

#+include: examples/attribute2.jsonnet src jsonnet

Compiling:

#+begin_src shell :exports results :results output code :wrap "SRC c++"
  moo compile examples/attribute2.jsonnet
#+end_src

#+RESULTS:
#+begin_src c++
[
    {
        "def": "purple",
        "name": "color",
        "type": "string"
    },
    {
        "def": 0,
        "name": "count",
        "type": "integer"
    }
]
#+end_src

While these Jsonnet examples are growing at a reasonable rate, their
compiled JSON are getting long and annoying.  Already Jsonnet's
brevity is appreciated by all you good readers.  Jsonnet is also
appreciated by me as it gives me more room than would JSON to ramble
one, like I'm doing right now.  Because it is getting in the way of my
own words, we'll dispense from showing the compiled JSON as we
continue.

** Object
   :PROPERTIES:
   :CUSTOM_ID: object
   :END:

Our next scaling up in complexity is, on the one hand, rather simple.
We combine a "name" with and array of attributes and call this an
~object~ (by which of course we mean, a /model of an object/ and not
an instance of an object itself).  The "name" we will interpret kind
of like a name for a type just like we do for the ~type.name~.

In fact, in some cases, we interpret the name exactly like a type in
the target programming language.  As we will one day see, some
templates will generate a target language ~struct~ or ~class~ name from a
object model's ~.name~.  In other cases we will generate a message
schema or generate code that can make messages and their ~name~ will be
held by the message as a type identifier field or some such.

We will also add an optional element to ~object~ which is a brief
documentation string called ~help~.  Here's an old friend which we saw
way up in [[Compiling Jsonnet Models]]:

#+include: examples/object1.jsonnet src jsonnet

As promised we'll omit the JSON.  You can compile the example yourself
if you really want to.  It's with all the others in [[file:examples/][examples/]] and is
~object1.jsonnet~.  We will care more to check what the compiled data
structure looks like when we get to writing templates.  Then, we will
care to know that a ~.name~ gives us the name, ~.attrs~ gives the array of
attributes and ~.help~ gives us the help string and that the attributes
and the help string might be empty.  This is the schema of ~object~ data
structures and because an ~object~ data structure is created through the
~moo.object()~ Jsonnet function that structure is schema-valid by
construction.

Let's pause to think more about our ~object~ as it will be central to
what comes.  It models a compound of typed and named things (the
~attrs~) and has a name that is kind of a type name.  Okay, so then
shouldn't we be able to model some ~object~ with one of its ~attrs~ that
is itself an ~object~?  Let's not ask for permission.  Let's just do it:

#+include: examples/object2.jsonnet src jsonnet

Well, that at least compiles to JSON.  We omitted the "help" for
brevity here but we'd never never neglect adding docstrings to the
real deal because we love our users far too much to neglect
documentation.

We also did not give a default value for the ~"snack"~ attribute (an
~object~) in the ~"eat"~ object like we did for attributes of basic type.
What sort of default can we give to this attribute which is an object?
The answer is none, so we give none and the ~moo.attribute()~ function
sets a JSON ~null~.  Templates that use this attribute model can still
make a default instance from an ~object~ as each attribute (that isn't
an ~object~) provide a default.

** Method
   :PROPERTIES:
   :CUSTOM_ID: method
   :END:

In the real world of programming we say a "method" is a function
called on an associated "instance".  The call possibly has some
arguments, each of a type and possibly returns a value of a type.  In
*moo* we'll use these same terms we will use them to refer to models.

We could model a method similar to how we model an object, with
~object~.  The ~name~ of the ~object~ could be the name of the method, the
~attributes~ of the ~object~ could be the arguments of the method.

But whence the return value and its type?  Faced with answering that,
we could instead model the method as an ~attribute~.  Then we'd have the
~name~, and the return value and its type.  But, now we've lost
arguments (I hate losing arguments).

We could make a special attribute of an ~object~ describe the return
type but that feels too invasive and layer smashing (I hate layer
smashing).

So let's make a new model for a method and call it ~method~ and let's
have it smoosh together an ~object~ and an ~attribute~.  BTW, "smoosh" is
a technical term of art used by all modelers of quality.  If you write
at least one *moo* model, you are allowed to use it.  Okay, so let's do
that so we have our two cakes and eat them each.  Blink one eye and
the resulting ~method~ data structure looks a whole lot like an
~attribute~.  Blink the other, it's an ~object~:

#+include: examples/method1.jsonnet src jsonnet

#+begin_example
  $ moo compile examples/method1.jsonnet
#+end_example

I promised no more JSON, and so there is no more but you can compile
this example yourself to bathe in the curly braces.  If you do so,
you can see how a ~method~ is both an ~attribute~ (with a ~name~, ~type~ and
~def~) and an ~object~ (with a ~name~, ~attrs~, and ~help~).

We also may see that the beauty of a ~method~ is, at best, skin deep.
It's all interface and no interguts.  We have no way to give it any
innards.  If there are any guts to serve at all, it is up to the
templates to do that carving.

** State Machine
   :PROPERTIES:
   :CUSTOM_ID: fsm
   :END:

The next kind of model is itself its own little world as *moo* supports
modeling (hierarchical) finite state machines (here, FSM does not stand for
/flying spaghetti monster/, may his Noodly Appendages always be al
dente).  If you do not know what FSMs are, go read [[https://en.wikipedia.org/wiki/Finite-state_machine][wikipedia]].  Go on,
I'll wait.  Also, be sure to read about [[https://en.wikipedia.org/wiki/UML_state_machine][UML state machine]].

Back already?  Fascinating stuff, wasn't it.  As you learned, FSMs
have a few interrelated parts and thus their modeling requires a few
interrelated models.  

FSM are important to the great protocol endpoint taxonomy that we
endeavor to one day define.  As programmers, we write FSMs all the
time without knowing we do so.  On the street they are called "an ugly
mess of if/then/else and sometimes goto".  But in the pristine halls
of academia (if I was still allowed in) we come up with names for
messes and call it science.  So, "hierarchical finite state machine"
it is.  And, in fairness, modeling the mess of branching we ultimately
always need gives us an excellent way to disentangle that mess and
approach something that might resemble beauty.

In *moo* we have a model for each FSM part.  They are named and
described as:

- ~state~ :: an alias to an ~object~ and in practice likely devoid of attributes.  The model ~.name~ is expected to be used in an instance of the ~state~ model as source or target in the FSM instance.
- ~event~ :: also an alias to an ~object~.  A generated instance of an event model is expected to use the model's ~.name~ attribute to drive FSM transitions.
- ~guard~ :: essentially a ~method~ with a hard-wired return type of ~bool~
- ~action~ :: essentially a ~method~ with a hard-wired ~void~ return type
- ~transition~ :: a new model with two required two state models (as ~.ini~ and ~.fin~) and three optional models: event (~.eve~), guards (~.grds~, an array of ~guard~) and actions (~.acts~ and array of ~action~).
- ~context~ :: an alias to an ~object~ model which describes some contextual data assumed to be accessible to the body of the guards and the actions as well as the larger context which is feeding events into the state machine.
- ~machine~ :: a new model that has a ~.name~ and a ~.tt~ attribute which holds an array of ~transition~.  The machine may also have a ~.context~.  Finally, a ~machine~ may also be used where a ~state~ model is used and that's what lets us use the fancy word "hierarchical".

Let's have an example of an FSM model.  If you compile it you'd see a
river of JSON.  I've heard some people like rivers of JSON.  I'll
stick with the Jsonnet:

#+include: examples/fsm1.jsonnet src jsonnet

#+begin_example
  $ moo compile examples/fsm1.jsonnet
#+end_example

Modeling FSMs in moo requires embracing some caveats.  Ultimately the
FSM implementation depends on how the template interprets the model.
This is true for all *moo* models and templates but it's extra true for
FSMs.  The template may use an FSM model to generate a nest of
~if/then/else~ branches or it may transliterate the ~tt~ into a transition
table lookup mechanism.  Likewise, the generated FSM may have the
instance of the ~context~ model explicitly passed into guard and action
methods as an argument or it may be somehow a "global".  In a likewise
or in a different fashion the current event instance may be made
available to these methods.

When we model the FSM we must know what data can be shared between the
FSM parts but the model doesn't specify *how* it is shared, or even that
it is shared, the template does.  We'll see how that plays out but for
now, just put it in your pocket.

This deferring decision power to the template unfortunately produces a
conceptual cycle between developing the model and the template.  Your
humble author apologizes but I squeak a defense that to further
specify the FSM in the model would limit how it may be implemented to
the extent that the model would hold implementation code and break my
promise that modeling does not require programming.  And in any case,
the goal is to have stable templates and fluid models.  Once we get
the templates correct we can document these details and developers of
future models can incorporate their constraints levied by the
templates into their own mental meta model of the *moo*.

** Command
   :PROPERTIES:
   :CUSTOM_ID: command
   :END:

We now start to get out of the low level world of navel gathering on
basic data structures and up our game to begin navel gathering on the
mythical "protocol endpoint taxonomy".

One of the most basic protocols is a back and maybe a forth exchange
between two entities.  I tell you to jump, you say how high.  Or,
maybe you simply ignore me.  Or, maybe you laugh in my face.  However
it may play out, *moo* calls this exchange a "command" and we model it
with a ~command~. 

A ~command~ models something very much like a ~method~.  In the generated
code we expect to call an instance of a ~method~ model and that may
return you value.  The ~name~ and ~arguments~ to a ~command~ instance may be
combined to form an ~object~ and we will think of that ~object~ as
modeling a message sent to the other endpoint.

That part is easy.  It's always easier to shout into the abyss.  It's
harder to know what to do when the abyss answers.  Many types of
messages may come back and we'd like to model what behavior a ~command~
should take as a reaction.  Thankfully we just spent a section talking
about how to model behavior and so we will use an FSM model.

Lastly, we have that return value to deal with.  At most the ~command~
model can define is the type and a default value for the return.  It
is the template that must say how a return is calculated and what in
the model might be used to do that.  Likewise, the template must
implement error handling and will levy requirements on the model to
generate its code.  For example, it may require certain attributes
that will be checked and converted to code that throws an exception.

This again brings us dangerously close to actual programming while it
was promised by *moo* (or rather by me) that we have slipped those
shackles.  It's also getting dangerously close to smashing layers
which someone recently claimed to hate.  Nonetheless we will try to
stay true to our word and walk a fine line.

Let's start by seeing how to construct a command model.

#+begin_src jsonnet
  local met = moo.method("open",...);
  local fsm = moo.machine( ... );
  moo.command(met, fsm, "Tell someone to open a door")
#+end_src

Well, after all that talk, that sure looks simple.  I see a method.  I
know what that is.  I see an FSM model.  No worries.  I see what looks
like a help string.  That's nice and friendly.

** Endpoint 
   :PROPERTIES:
   :CUSTOM_ID: endpoint
   :END:

An endpoint there means one end if a protocol conversation and
~endpoint~ models it.  The "point" of an endpoint should be considered
to live in isolation only reacting to input by producing output.

** API
   :PROPERTIES:
   :CUSTOM_ID: api
   :END:

An API models a number of commands that govern a captive endpoint.
For example, an API template may generate an API class which
application will instantiate and through its methods it will send
command messages into an endpoint FSM and get back responses.  That
FSM may also be handling messages from the cosmos.


** Template Model

We'll next go on to templates themselves.  We'll see how they may
assume a somewhat different model than the model models.  In some
cases a template expect to be given a data structure which may be
provided as some substructure of a model.  In these cases it's enough
to dig out that substructure with ~moo generate -p dot.path~ as
described above in [[Filtering Structure]].  In other cases we must make
whole new Jsonnet files that use ~import~ and aggregate parts into new
forms and possibly even apply complex functions to rearrange the model
into a form the template can digest.  We'll see this almost
immediately in the example ~echo-ctxsml.jsonnet~.


* Templates
  :PROPERTIES:
  :CUSTOM_ID: templates
  :END:

  #+begin_quote
  I may not know but I sure can do.
  #+end_quote

We met templates already and on the surface they seem pretty
straightforward.  But it is with templates that we try to capture a
programmer's experience (or, inexperience as the case may be).  To the
extent possible, the [[https://en.wikipedia.org/wiki/Concern_(computer_science)][concerns]] of the template are orthogonal to the
concerns of the model, but as we described above, the templates levy
requirements details of how parts of the model should be constructed.
A template may assume a model follows a general schema dictated by *moo*
functions and their schema-valid-by-construction assurances but at
some level of detail the actual schema is defined by what the template
accepts.

This section will build up templates and a model for an "echo"
protocol and its endpoint handlers.  In the process, the templates we
will create may be used unchanged to generate other far more complex
protocols just by changing the model.  That's the promise of *moo*.
Let's now see if it works.

There are two major parts to the code that will be generated:

- proto :: a class that provides a protocol handler endpoint.  This
  has an FSM at its core and spins merrily in a thread of its own,
  thus enacting the actor pattern.  It has sockets to talk to the
  universe and sockets that talk to the application.  

- api :: a class that provides an interface between the protocol
  handler and the application.  It's purpose is to provide a simple,
  largely synchronous way for an application to interact with the
  whirling dervish protocol handler inside its actor thread.  

If this dichotomy sounds familiar, you are probably familiar with
ZeroMQ's Zproto because that's exactly from where I stole this design.
Zproto makes a distinction between "client" and "server" endpoints but
the "echo" protocol we use for fleshing out these generic templates
will be more or less symmetric.  The hope is then that these templates
can be reused, as is, for asymmetric and dare we hope even arbitrary
protocols.

Let's now begin our stroll, one template at a time.

** Context State Machine

Here our goal is to generate a C++ ~struct~ which provides the modeled
FSM.  Any guards and actions will be generated as unimplemented
methods on the ~struct~ and the ~context~ will be available to these
methods as a data member.  This will produces a C++ header and the
programmer will be responsible for providing the method
implementations.

A ~machine~ model is almost all that is needed but a few ancillary bits
of info will also be required.  Thus a top-level object (not ~object~)
must provide the full model.  It must have these keys:

- ~namespace~ :: a literal string giving a C++ namespace in which all code lives.
- ~structname~ :: a literal string giving the C++ ~struct~ type name.
- ~machine~ :: a ~machine~ model.

The template is in [[file:templates/ctxsml.hpp.j2]] and our test model is in [[file:examples/echo-ctxsml.jsonnet]].

#+begin_src shell
  moo generate examples/echo-ctxsml.jsonnet templates/ctxsml.hpp.j2
#+end_src





* Build system
  :PROPERTIES:
  :CUSTOM_ID: waf
  :END:

Waf.

* Doing it differently

- make models in other ways like with Python code
- the joy of Zproto
